{"meta":{"title":"Limbo's Wiki","subtitle":"","description":"","author":"Limbo","url":"http://taizilongxu.github.io/wiki","root":"/wiki/"},"pages":[{"title":"About","date":"2020-03-01T12:03:15.128Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"about/index.html","permalink":"http://taizilongxu.github.io/wiki/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2020-03-01T12:03:15.222Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"categories/index.html","permalink":"http://taizilongxu.github.io/wiki/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-03-01T12:03:15.332Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"tags/index.html","permalink":"http://taizilongxu.github.io/wiki/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LDAP","slug":"杂项/ldap","date":"2020-08-02T16:49:35.000Z","updated":"2020-08-02T16:49:35.000Z","comments":true,"path":"wiki/杂项/ldap/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/%E6%9D%82%E9%A1%B9/ldap/","excerpt":"","text":"背景LDAP (Lightweight Directory Access Protocol) 轻型目录访问协议 主要用于单点登录(SSO) 两种实现OpenLDAP 和 ActiveDirectory(微软的域控制器) 基本概念 目录树: 目录服务为树形 条目: 每个记录叫做条目, 每个条目又唯一的可区别名称(distinguished name, DN) 对象类: 类比语言中的 class 属性: 类比语言重的类属性 目录树结构 LDAP 属性 属性 英文 含义 DC Domain Component 域名的部分，其格式是将完整的域名分成几部分，如域名为example.com变成dc=example,dc=com（一条记录的所属位置） UID User Id 用户ID songtao.xu（一条记录的ID） OU Organization Unit 组织单位，组织单位可以包含其他各种对象（包括其他组织单元），如“oa组”（一条记录的所属组织） CN Common Name 公共名称，如“Thomas Johansson”（一条记录的名称） DN Distinguished Name “uid=songtao.xu,ou=oa组,dc=example,dc=com”，一条记录的位置（唯一） 原理大致说下原理, 无非就是根据树形结构检索要查询的用户比对密码, 一般程序会设置一个 baseDN, 是整个 LDAP 管理者账号的信息 然后会设置一个 userDN, 是查询用户信息的树结构地址, 这两个地址节点越多代表搜索范围越小, 还会有一个用户组 group 查询, 这3个都差不多","categories":[{"name":"杂项","slug":"杂项","permalink":"http://taizilongxu.github.io/wiki/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"威士忌","slug":"生活/whiskey","date":"2020-08-02T16:28:10.000Z","updated":"2020-08-02T16:28:10.000Z","comments":true,"path":"wiki/生活/whiskey/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/%E7%94%9F%E6%B4%BB/whiskey/","excerpt":"","text":"威士忌: 酿造原料必须是谷物, 比如大麦 一定是蒸馏酒 必须在橡木桶种陈年储藏 按原料分类: 单一麦芽 Single Malt: 只用水和大麦麦芽, 不加任何谷物 单一谷物 Single Grain: 除了大麦加入其他谷物, 例如玉米, 小麦或者未做发芽处理的大麦 调和纯麦 Blended Malt: 至少两个单一麦芽 调和谷物 Blended Grain: 至少两家单一谷物 调和 Blended: 至少一种单一谷物和至少一种单一麦芽 按产地分类: 英格兰 苏格兰 美国 加拿大 日本 平民酒 产地 品牌 容量 种类 价格 口感 苏格兰 格兰 Grant’s 雪莉珍藏 700ml 调和威士忌 60 口粮酒, 单喝不错, 泥煤加雪莉 苏格兰 百龄坛 Ballantine’s 特纯 500ml 调和威士忌 50 单喝不好喝, 可能得兑点东西 苏格兰 高司令 High Commissioner 200ml 调和纯麦 20 口粮酒, 一般, 便宜 英格兰 尊尼获加 Johnnie Walker 黑方 700ml 调和威士忌 英格兰 尊尼获加 Johnnie Walker 绿方 700ml 调和威士忌 英格兰 尊尼获加 Johnnie Walker 红方 700ml 调和威士忌 英格兰 尊尼获加 Johnnie Walker 绿方 700ml 调和威士忌 美国田纳西 杰克丹尼 Jack Daniel’s 700ml 调和威士忌 110 台湾 金车噶玛兰 KAVALAN 珍选 700ml 单一麦芽 200 不太喜欢, 有点烈","categories":[{"name":"生活","slug":"生活","permalink":"http://taizilongxu.github.io/wiki/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"Helmet","slug":"生活/helmet","date":"2020-08-02T16:27:22.000Z","updated":"2020-08-02T16:27:22.000Z","comments":true,"path":"wiki/生活/helmet/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/%E7%94%9F%E6%B4%BB/helmet/","excerpt":"","text":"品牌 型号 又名 重量 Snell 认证 Sharp 认证 价格 Shoei x14 1400+-50g √ 4280/5000 z7 NXR 1310~1470g ⭐⭐⭐⭐ 2780/3250 GT-AIR 1615g ⭐⭐⭐ Arai rx7x rx-7v √ 3380/3900 xd 1595-1675g √ 3100/3700 Quantum ⭐⭐⭐ Hjc RPHA11 1350+-50g ⭐⭐⭐ 4500 c70 ⭐⭐⭐⭐⭐ i70 1600+-50g ⭐⭐⭐⭐ 1400 snell 认证: https://www.smf.org/cert sharp 认证: https://sharp.dft.gov.uk/","categories":[{"name":"生活","slug":"生活","permalink":"http://taizilongxu.github.io/wiki/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"auth","slug":"auth","date":"2020-06-23T07:33:47.050Z","updated":"2020-06-23T07:37:39.441Z","comments":true,"path":"wiki/auth/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/auth/","excerpt":"","text":"Authentication(鉴定): Kerberros User/Group Mapping: LDAP Authorization(授权): Ranger","categories":[],"tags":[]},{"title":"zookeeper","slug":"zookeeper","date":"2020-06-03T06:28:36.612Z","updated":"2020-07-09T04:21:45.480Z","comments":true,"path":"wiki/zookeeper/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/zookeeper/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"hbase","slug":"hbase","date":"2020-06-03T06:28:32.013Z","updated":"2020-06-05T13:11:14.787Z","comments":true,"path":"wiki/hbase/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/hbase/","excerpt":"","text":"参考资料: http://iambigboss.top/post/72413_1_1.html https://cshihong.github.io/2018/05/17/HBase%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/","categories":[],"tags":[]},{"title":"博物馆","slug":"生活/museum","date":"2020-06-01T05:11:43.489Z","updated":"2020-06-01T05:19:50.045Z","comments":true,"path":"wiki/生活/museum/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/%E7%94%9F%E6%B4%BB/museum/","excerpt":"","text":"名称 网址 中国园林博物馆 http://www.gardensmuseum.cn/ 中国国家博物馆 http://www.chnmuseum.cn/ 故宫博物院 https://www.dpm.org.cn/","categories":[{"name":"生活","slug":"生活","permalink":"http://taizilongxu.github.io/wiki/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"LVS(Linux Virtual Server)","slug":"lvs","date":"2020-05-03T18:42:14.000Z","updated":"2020-07-09T04:21:05.783Z","comments":true,"path":"wiki/lvs/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/lvs/","excerpt":"","text":"参考资料: https://www.cnblogs.com/walkman-sky/p/12197805.html","categories":[],"tags":[]},{"title":"","slug":"Network/virtual_IP_address","date":"2020-05-03T18:41:29.000Z","updated":"2020-06-01T12:29:07.639Z","comments":true,"path":"wiki/Network/virtual_IP_address/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Network/virtual_IP_address/","excerpt":"","text":"参考资料: https://www.zhihu.com/question/67682565 http://xiaobaoqiu.github.io/blog/2015/04/02/xu-ni-iphe-ippiao-yi/ 虚拟 IP只是通过 ARP 协议协调路由达到主备切换","categories":[{"name":"Network","slug":"Network","permalink":"http://taizilongxu.github.io/wiki/categories/Network/"}],"tags":[]},{"title":"python 内存","slug":"Python/pythonMemory","date":"2020-05-03T17:34:48.000Z","updated":"2020-05-03T17:34:48.000Z","comments":true,"path":"wiki/Python/pythonMemory/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Python/pythonMemory/","excerpt":"","text":"https://docs.python.org/3/c-api/memory.html https://realpython.com/python-memory-management/ https://rushter.com/blog/python-memory-managment/ https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/memory_management/memory_management_cn.md 代码 内存池机制 大内存使用 malloc 分配 小内存使用内存池分配 Python 内存池 第3层: 最上层, 用户对 Python 对象操作 第1/2层: 内存池，由 Python 的接口函数 PyMem_Malloc 实现—–若请求分配的内存在1~256字节之间就使用内存池管理系统进行分配，调用malloc函数分配内存，但是每次只会分配一块大小为256K的大块内存，不会调用free函数释放内存，将该内存块留在内存池中以便下次使用。 第 0 层: 大内存, 若请求分配的内存大于256K，malloc函数分配内存，free函数释放内存 第 -1/-2 层: 操作系统进行操作 三层结构 Arena: 直接向系统申请空间 Pool: 相同大小 block 集合, 总大小和系统 memory page 相同(4kb) block: 最小分配单位 说明: Arena 会一次性创建 16 个, 每个 Areana 含 64 个 pool 垃圾回收机制 引用计数ref += 1 标记清除核心原理: 标记阶段: 标记所有引用为 1 的对象为 unreachable, 然后对不为 1 的对象进行调用遍历,如果被引用则将整个引用链上的对象对象从 unreachable 状态变为 reacheable 清除阶段: 删除 unreachable 对象 上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。 分代回收在程序里存货时间越久, 扫描越少 分为 0, 1, 2 总共 3 代 查看和调整函数 12gc.get_threshold() # (threshold0, threshold1, threshold2).gc.set_threshold(threshold0[, threshold1[, threshold2]])","categories":[{"name":"Python","slug":"Python","permalink":"http://taizilongxu.github.io/wiki/categories/Python/"}],"tags":[]},{"title":"Dict","slug":"Python/pythoDict","date":"2020-04-04T11:29:17.000Z","updated":"2020-04-04T11:29:17.000Z","comments":true,"path":"wiki/Python/pythoDict/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Python/pythoDict/","excerpt":"","text":"https://www.python.org/dev/peps/pep-0412/ https://flaggo.github.io/python3-source-code-analysis/objects/dict-object/ https://www.slideshare.net/delimitry/python-dictionary-past-present-future https://github.com/zpoint/CPython-Internals/blob/master/BasicObject/dict/dict_cn.md 结构代码位置: Include/cpython/dictobject.h 12345678910111213141516171819typedef struct &#123; PyObject_HEAD /* Number of items in the dictionary */ Py_ssize_t ma_used; /* Dictionary version: globally unique, value change each time the dictionary is modified */ uint64_t ma_version_tag; PyDictKeysObject *ma_keys; /* If ma_values is NULL, the table is \"combined\": keys and values are stored in ma_keys. If ma_values is not NULL, the table is splitted: keys are stored in ma_keys and values are stored in ma_values */ PyObject **ma_values;&#125; PyDictObject; 代码位置: Objects/dict-common.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// PyDictKeysObjectstruct _dictkeysobject &#123; Py_ssize_t dk_refcnt; /* Size of the hash table (dk_indices). It must be a power of 2. */ Py_ssize_t dk_size; /* Function to lookup in the hash table (dk_indices): - lookdict(): general-purpose, and may return DKIX_ERROR if (and only if) a comparison raises an exception. - lookdict_unicode(): specialized to Unicode string keys, comparison of which can never raise an exception; that function can never return DKIX_ERROR. - lookdict_unicode_nodummy(): similar to lookdict_unicode() but further specialized for Unicode string keys that cannot be the &lt;dummy&gt; value. - lookdict_split(): Version of lookdict() for split tables. */ dict_lookup_func dk_lookup; /* Number of usable entries in dk_entries. */ Py_ssize_t dk_usable; /* Number of used entries in dk_entries. */ Py_ssize_t dk_nentries; /* Actual hash table of dk_size entries. It holds indices in dk_entries, or DKIX_EMPTY(-1) or DKIX_DUMMY(-2). Indices must be: 0 &lt;= indice &lt; USABLE_FRACTION(dk_size). The size in bytes of an indice depends on dk_size: - 1 byte if dk_size &lt;= 0xff (char*) - 2 bytes if dk_size &lt;= 0xffff (int16_t*) - 4 bytes if dk_size &lt;= 0xffffffff (int32_t*) - 8 bytes otherwise (int64_t*) Dynamically sized, SIZEOF_VOID_P is minimum. */ char dk_indices[]; /* char is required to avoid strict aliasing. */ /* \"PyDictKeyEntry dk_entries[dk_usable];\" array follows: see the DK_ENTRIES() macro */&#125;; 代码位置: Objects/dict-common.h 123456typedef struct &#123; /* Cached hash code of me_key. */ Py_hash_t me_hash; PyObject *me_key; PyObject *me_value; /* This field is only meaningful for combined tables */&#125; PyDictKeyEntry Type类型代码位置: Objects/dictobject.c 123456789101112131415161718192021222324252627282930313233343536373839404142PyTypeObject PyDict_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) \"dict\", sizeof(PyDictObject), 0, (destructor)dict_dealloc, /* tp_dealloc */ 0, /* tp_vectorcall_offset */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_as_async */ (reprfunc)dict_repr, /* tp_repr */ &amp;dict_as_number, /* tp_as_number */ &amp;dict_as_sequence, /* tp_as_sequence */ &amp;dict_as_mapping, /* tp_as_mapping */ PyObject_HashNotImplemented, /* tp_hash */ 0, /* tp_call */ 0, /* tp_str */ PyObject_GenericGetAttr, /* tp_getattro */ 0, /* tp_setattro */ 0, /* tp_as_buffer */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_DICT_SUBCLASS, /* tp_flags */ dictionary_doc, /* tp_doc */ dict_traverse, /* tp_traverse */ dict_tp_clear, /* tp_clear */ dict_richcompare, /* tp_richcompare */ 0, /* tp_weaklistoffset */ (getiterfunc)dict_iter, /* tp_iter */ 0, /* tp_iternext */ mapp_methods, /* tp_methods */ 0, /* tp_members */ 0, /* tp_getset */ 0, /* tp_base */ 0, /* tp_dict */ 0, /* tp_descr_get */ 0, /* tp_descr_set */ 0, /* tp_dictoffset */ dict_init, /* tp_init */ PyType_GenericAlloc, /* tp_alloc */ dict_new, /* tp_new */ PyObject_GC_Del, /* tp_free */&#125;; C 接口代码位置: Include/dictobject.h 12345678910111213141516PyObject *PyDict_New(void)&#123; dictkeys_incref(Py_EMPTY_KEYS); return new_dict(Py_EMPTY_KEYS, empty_values);&#125;static PyDictKeysObject empty_keys_struct = &#123; 1, /* dk_refcnt */ 1, /* dk_size */ lookdict_split, /* dk_lookup */ 0, /* dk_usable (immutable) */ 0, /* dk_nentries */ &#123;DKIX_EMPTY, DKIX_EMPTY, DKIX_EMPTY, DKIX_EMPTY, DKIX_EMPTY, DKIX_EMPTY, DKIX_EMPTY, DKIX_EMPTY&#125;, /* dk_indices */&#125;; 初始化 dict 大小为 8","categories":[{"name":"Python","slug":"Python","permalink":"http://taizilongxu.github.io/wiki/categories/Python/"}],"tags":[]},{"title":"食材","slug":"生活/food","date":"2020-04-03T16:26:47.000Z","updated":"2020-04-03T16:26:47.000Z","comments":true,"path":"wiki/生活/food/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/%E7%94%9F%E6%B4%BB/food/","excerpt":"","text":"硬件 电饭锅 电磁炉: 米家电磁炉青春版 煎锅, 雪平锅 厨房纸 砧板 刀具: 三德刀基本够用, 后期升级可以加个切片刀 拌料 橄榄油, PAM喷油 黑胡椒 孜然 盐 酱油 料酒 耗油 卡真粉 迷迭香 热量计算公式1大卡 = 4.184 千焦 食材蛋白质 名称 GI 热量大卡 常温存储 冷藏存储 冷冻存储 牛肉🐂 46 318 2小时 1-2天 6-8月 鸡胸肉🐓 45 200 2小时 1-2天 1年 龙利鱼🐟 40 67 2小时 1-2天 6-9月 金枪鱼🐟 40 99 2小时 1-2天 6-9月 沙丁鱼🐟 40 89 2小时 1-2天 6-9月 虾仁🍤 40 83 鸡蛋🥚 30 151 数小时 3-4周 不可 牛奶🥛 25 67 数小时 5-7天 1个月 培根🥓 49 405 2小时 2周 4个月 蔬菜 名称 GI 热量大卡 常温存储 冷藏存储 冷冻存储 玉米🌽 70 92 1-3天 1-2周 3-5月 红萝卜🥕 80 37 4天 4-5周 8-12月 马铃薯🥔 90 65 1个月 3-4月 不可冷冻 红薯 76 61 山药 75 50 番茄🍅 30 19 5-7天 2周 8-12月 黄瓜🥒 23 14 1-3天 1周 8-12月 西兰花🥦 25 36 2天 7-14天 8-12月 南瓜🎃 65 91 主食 名称 GI 热量大卡 米饭🍚 84 356 馒头 88 233 糙米🍚 56 350 燕麦🥣 55 380 全麦面包🍞 50 378 黑麦面包🍞 58 264 意大利面🍝 55 378 荞麦面🍝 59 274 水果 名称 GI 热量大卡 常温存储 冷藏存储 冷冻存储 香蕉🍌 55 154 2-7天 5-9天 2-3个月 芒果🥭 49 64 哈密瓜🍈 41 42 熟透之前 1周 8-12月 桃子🍑 41 40 熟透之前 2-5天 8-12个月 苹果🍎 36 54 2-4周 1-2月 8-12月 奇异果🥝 35 35 梨🍐 32 43 木瓜 30 38 橙子🍊 31 46 橘子🍊 31 60 柠檬🍋 34 54 2-4周 1-2月 3-4月 草莓🍓 29 34 1-2天 5-7天 6-8个月 葡萄🍇 50 55 3-5天 7-10天 3-5个月 健身餐牛排素材 牛排 橄榄油 黑胡椒 盐 过程 冷藏解冻, 室温解冻或者冷水解冻 不用水清洗, 用厨房纸擦干水分 室温回温至少 30 min 以上, 厚的 1 小时以上 抹上橄榄油, 两面用黑胡椒和盐调味 15s 一次翻面 醒肉 电饭锅煮鸡蛋素材 鸡蛋 水 过程 电饭锅铺上餐厨纸 均匀浇上 100ml 水 等待跳闸后闷 5 分钟 拿出放入凉水冷却好扒皮 蒸紫薯素材: 紫薯 过程 切块 蒸 10-20 分钟 去皮搅碎即可 煎鸡胸肉素材: 鸡胸 过程 解冻, 室温或者流水 切片或块, 更容易煎, 然后倒入生抽, 料酒和耗油腌制 30 分钟 生抽, 料酒, 耗油腌制 黑胡椒, 海盐 盐, 胡椒, 卡真粉 大火煎至两面金黄色 意面素材 意面 味好美意面酱 牛肉碎 番茄 过程 沸水煮 10 分钟, 加一点盐, 捞出抹橄榄油备用 料酒, 淀粉腌制下牛肉碎, 放入炒锅开始炒 肉色变化后放入番茄 番茄差不多放入意面酱, 倒入200ml 水, 小火焖煮 放入意面炒差不多可以出锅了 最后放点黑胡椒, 味道不够可以加点黑胡椒酱 燕麦片素材 燕麦片 牛奶 香蕉","categories":[{"name":"生活","slug":"生活","permalink":"http://taizilongxu.github.io/wiki/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"Float","slug":"Python/pythonFloat","date":"2020-03-28T18:08:55.000Z","updated":"2020-03-28T18:10:09.000Z","comments":true,"path":"wiki/Python/pythonFloat/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Python/pythonFloat/","excerpt":"","text":"结构代码位置: Include/floatobject.h 1234typedef struct &#123; PyObject_HEAD double ob_fval;&#125; PyFloatObject; Type类型代码位置: Objects/floatobject.c 1234567891011121314PyTypeObject PyFloat_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) \"float\", sizeof(PyFloatObject), 0, (destructor)float_dealloc, /* tp_dealloc */ // ... (reprfunc)float_repr, /* tp_repr */ 0, /* tp_init */ 0, /* tp_alloc */ float_new, /* tp_new */&#125;; Float 看来没啥东西","categories":[{"name":"Python","slug":"Python","permalink":"http://taizilongxu.github.io/wiki/categories/Python/"}],"tags":[]},{"title":"String","slug":"Python/pythonString","date":"2020-03-28T18:03:41.000Z","updated":"2020-03-28T18:03:41.000Z","comments":true,"path":"wiki/Python/pythonString/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Python/pythonString/","excerpt":"","text":"参考资料: https://www.python.org/dev/peps/pep-0393/ https://docs.python.org/3/c-api/unicode.html#creating-and-accessing-unicode-strings https://rushter.com/blog/python-strings-and-memory/ https://timothybramlett.com/Strings_Bytes_and_Unicode_in_Python_2_and_3.html https://nedbatchelder.com/text/unipain.html https://www.cnblogs.com/c-x-a/p/11408372.html compact 和 legacy compact: 创建的时候知道长度和最大 character 的使用 compact, character 紧跟在 base structer 后面, 如果最大 character 小于 128 则使用 PyASCIIObject 结构, 如果大于 128 则使用 PyCompactUnicodeObject legacy: 创建的时候不知道最大 character 的使用 legacy, 使用 PyUnicode_FromStringAndSize(NULL, length) 创建, 在内部他们的数据只保存在 wstr 里面. 当 PyUnicode_READY 被调用, data pointer 就被分配了. Resizing 只能在PyUnicode_READY 之前调用. kind 00 =&gt; str is not initialized (data are in wstr) 01 =&gt; 1 byte (Latin-1) 10 =&gt; 2 byte (UCS-2) 11 =&gt; 4 byte (UCS-4) 结构代码位置: Include/cpython/unicodeobject.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/* ASCII-only strings created through PyUnicode_New use the PyASCIIObject structure. state.ascii and state.compact are set, and the data immediately follow the structure. utf8_length and wstr_length can be found in the length field; the utf8 pointer is equal to the data pointer. */typedef struct &#123; /* There are 4 forms of Unicode strings: - compact ascii: * structure = PyASCIIObject * test: PyUnicode_IS_COMPACT_ASCII(op) * kind = PyUnicode_1BYTE_KIND * compact = 1 * ascii = 1 * ready = 1 * (length is the length of the utf8 and wstr strings) * (data starts just after the structure) * (since ASCII is decoded from UTF-8, the utf8 string are the data) - compact: * structure = PyCompactUnicodeObject * test: PyUnicode_IS_COMPACT(op) &amp;&amp; !PyUnicode_IS_ASCII(op) * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or PyUnicode_4BYTE_KIND * compact = 1 * ready = 1 * ascii = 0 * utf8 is not shared with data * utf8_length = 0 if utf8 is NULL * wstr is shared with data and wstr_length=length if kind=PyUnicode_2BYTE_KIND and sizeof(wchar_t)=2 or if kind=PyUnicode_4BYTE_KIND and sizeof(wchar_t)=4 * wstr_length = 0 if wstr is NULL * (data starts just after the structure) - legacy string, not ready: * structure = PyUnicodeObject * test: kind == PyUnicode_WCHAR_KIND * length = 0 (use wstr_length) * hash = -1 * kind = PyUnicode_WCHAR_KIND * compact = 0 * ascii = 0 * ready = 0 * interned = SSTATE_NOT_INTERNED * wstr is not NULL * data.any is NULL * utf8 is NULL * utf8_length = 0 - legacy string, ready: * structure = PyUnicodeObject structure * test: !PyUnicode_IS_COMPACT(op) &amp;&amp; kind != PyUnicode_WCHAR_KIND * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or PyUnicode_4BYTE_KIND * compact = 0 * ready = 1 * data.any is not NULL * utf8 is shared and utf8_length = length with data.any if ascii = 1 * utf8_length = 0 if utf8 is NULL * wstr is shared with data.any and wstr_length = length if kind=PyUnicode_2BYTE_KIND and sizeof(wchar_t)=2 or if kind=PyUnicode_4BYTE_KIND and sizeof(wchar_4)=4 * wstr_length = 0 if wstr is NULL Compact strings use only one memory block (structure + characters), whereas legacy strings use one block for the structure and one block for characters. Legacy strings are created by PyUnicode_FromUnicode() and PyUnicode_FromStringAndSize(NULL, size) functions. They become ready when PyUnicode_READY() is called. See also _PyUnicode_CheckConsistency(). */ PyObject_HEAD Py_ssize_t length; /* Number of code points in the string */ Py_hash_t hash; /* Hash value; -1 if not set */ struct &#123; /* SSTATE_NOT_INTERNED (0) SSTATE_INTERNED_MORTAL (1) SSTATE_INTERNED_IMMORTAL (2) If interned != SSTATE_NOT_INTERNED, the two references from the dictionary to this object are *not* counted in ob_refcnt. */ unsigned int interned:2; /* Character size: - PyUnicode_WCHAR_KIND (0): * character type = wchar_t (16 or 32 bits, depending on the platform) - PyUnicode_1BYTE_KIND (1): * character type = Py_UCS1 (8 bits, unsigned) * all characters are in the range U+0000-U+00FF (latin1) * if ascii is set, all characters are in the range U+0000-U+007F (ASCII), otherwise at least one character is in the range U+0080-U+00FF - PyUnicode_2BYTE_KIND (2): * character type = Py_UCS2 (16 bits, unsigned) * all characters are in the range U+0000-U+FFFF (BMP) * at least one character is in the range U+0100-U+FFFF - PyUnicode_4BYTE_KIND (4): * character type = Py_UCS4 (32 bits, unsigned) * all characters are in the range U+0000-U+10FFFF * at least one character is in the range U+10000-U+10FFFF */ unsigned int kind:3; /* Compact is with respect to the allocation scheme. Compact unicode objects only require one memory block while non-compact objects use one block for the PyUnicodeObject struct and another for its data buffer. */ unsigned int compact:1; /* The string only contains characters in the range U+0000-U+007F (ASCII) and the kind is PyUnicode_1BYTE_KIND. If ascii is set and compact is set, use the PyASCIIObject structure. */ unsigned int ascii:1; /* The ready flag indicates whether the object layout is initialized completely. This means that this is either a compact object, or the data pointer is filled out. The bit is redundant, and helps to minimize the test in PyUnicode_IS_READY(). */ unsigned int ready:1; /* Padding to ensure that PyUnicode_DATA() is always aligned to 4 bytes (see issue #19537 on m68k). */ unsigned int :24; &#125; state; wchar_t *wstr; /* wchar_t representation (null-terminated) */&#125; PyASCIIObject;/* Non-ASCII strings allocated through PyUnicode_New use the PyCompactUnicodeObject structure. state.compact is set, and the data immediately follow the structure. */typedef struct &#123; PyASCIIObject _base; Py_ssize_t utf8_length; /* Number of bytes in utf8, excluding the * terminating \\0. */ char *utf8; /* UTF-8 representation (null-terminated) */ Py_ssize_t wstr_length; /* Number of code points in wstr, possible * surrogates count as two code points. */&#125; PyCompactUnicodeObject;/* Strings allocated through PyUnicode_FromUnicode(NULL, len) use the PyUnicodeObject structure. The actual string data is initially in the wstr block, and copied into the data block using _PyUnicode_Ready. */typedef struct &#123; PyCompactUnicodeObject _base; union &#123; void *any; Py_UCS1 *latin1; Py_UCS2 *ucs2; Py_UCS4 *ucs4; &#125; data; /* Canonical, smallest-form Unicode buffer */&#125; PyUnicodeObject; 代码位置: Objects/unicodeobject.c 12345678910111213PyTypeObject PyUnicode_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) \"str\", /* tp_name */ sizeof(PyUnicodeObject), /* tp_basicsize */ 0, /* tp_itemsize */ /* Slots */ (destructor)unicode_dealloc, /* tp_dealloc */ ... 0, /* tp_init */ 0, /* tp_alloc */ unicode_new, /* tp_new */ PyObject_Del, /* tp_free */&#125;; C 接口代码位置: Objects/unicodeobject.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113PyObject *PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)&#123; PyObject *obj; PyCompactUnicodeObject *unicode; void *data; enum PyUnicode_Kind kind; int is_sharing, is_ascii; Py_ssize_t char_size; Py_ssize_t struct_size; /* Optimization for empty strings */ if (size == 0 &amp;&amp; unicode_empty != NULL) &#123; Py_INCREF(unicode_empty); return unicode_empty; &#125; is_ascii = 0; is_sharing = 0; struct_size = sizeof(PyCompactUnicodeObject); if (maxchar &lt; 128) &#123; kind = PyUnicode_1BYTE_KIND; char_size = 1; is_ascii = 1; struct_size = sizeof(PyASCIIObject); &#125; else if (maxchar &lt; 256) &#123; kind = PyUnicode_1BYTE_KIND; char_size = 1; &#125; else if (maxchar &lt; 65536) &#123; kind = PyUnicode_2BYTE_KIND; char_size = 2; if (sizeof(wchar_t) == 2) is_sharing = 1; &#125; else &#123; if (maxchar &gt; MAX_UNICODE) &#123; PyErr_SetString(PyExc_SystemError, \"invalid maximum character passed to PyUnicode_New\"); return NULL; &#125; kind = PyUnicode_4BYTE_KIND; char_size = 4; if (sizeof(wchar_t) == 4) is_sharing = 1; &#125; /* Ensure we won't overflow the size. */ if (size &lt; 0) &#123; PyErr_SetString(PyExc_SystemError, \"Negative size passed to PyUnicode_New\"); return NULL; &#125; if (size &gt; ((PY_SSIZE_T_MAX - struct_size) / char_size - 1)) return PyErr_NoMemory(); /* Duplicated allocation code from _PyObject_New() instead of a call to * PyObject_New() so we are able to allocate space for the object and * it's data buffer. */ obj = (PyObject *) PyObject_MALLOC(struct_size + (size + 1) * char_size); if (obj == NULL) return PyErr_NoMemory(); obj = PyObject_INIT(obj, &amp;PyUnicode_Type); if (obj == NULL) return NULL; unicode = (PyCompactUnicodeObject *)obj; if (is_ascii) data = ((PyASCIIObject*)obj) + 1; else data = unicode + 1; _PyUnicode_LENGTH(unicode) = size; _PyUnicode_HASH(unicode) = -1; _PyUnicode_STATE(unicode).interned = 0; _PyUnicode_STATE(unicode).kind = kind; _PyUnicode_STATE(unicode).compact = 1; _PyUnicode_STATE(unicode).ready = 1; _PyUnicode_STATE(unicode).ascii = is_ascii; if (is_ascii) &#123; ((char*)data)[size] = 0; _PyUnicode_WSTR(unicode) = NULL; &#125; else if (kind == PyUnicode_1BYTE_KIND) &#123; ((char*)data)[size] = 0; _PyUnicode_WSTR(unicode) = NULL; _PyUnicode_WSTR_LENGTH(unicode) = 0; unicode-&gt;utf8 = NULL; unicode-&gt;utf8_length = 0; &#125; else &#123; unicode-&gt;utf8 = NULL; unicode-&gt;utf8_length = 0; if (kind == PyUnicode_2BYTE_KIND) ((Py_UCS2*)data)[size] = 0; else /* kind == PyUnicode_4BYTE_KIND */ ((Py_UCS4*)data)[size] = 0; if (is_sharing) &#123; _PyUnicode_WSTR_LENGTH(unicode) = size; _PyUnicode_WSTR(unicode) = (wchar_t *)data; &#125; else &#123; _PyUnicode_WSTR_LENGTH(unicode) = 0; _PyUnicode_WSTR(unicode) = NULL; &#125; &#125;#ifdef Py_DEBUG unicode_fill_invalid((PyObject*)unicode, 0);#endif assert(_PyUnicode_CheckConsistency((PyObject*)unicode, 0)); return obj;&#125; 这边只是初始化内存空间, 根据长度和最大字符来进行初始化, 分位两种 PyCompactUnicodeObject 和 PyASCIIObject Intern共享机制, 只对字母数字下划线的字符串进行共享 至此, 感觉理解差不多了, 对于更详细的等有空再来补充","categories":[{"name":"Python","slug":"Python","permalink":"http://taizilongxu.github.io/wiki/categories/Python/"}],"tags":[]},{"title":"Python 内建类型","slug":"Python/pythonInternalObject","date":"2020-03-28T18:02:41.000Z","updated":"2020-03-28T18:02:41.000Z","comments":true,"path":"wiki/Python/pythonInternalObject/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Python/pythonInternalObject/","excerpt":"","text":"参考资料: https://flaggo.github.io/python3-source-code-analysis/objects/long-object/ 123456789101112131415161718typedef struct _typeobject &#123; PyObject_VAR_HEAD const char *tp_name; /* For printing, in format \"&lt;module&gt;.&lt;name&gt;\" */ Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ // ... /* Method suites for standard classes */ PyNumberMethods *tp_as_number; PySequenceMethods *tp_as_sequence; PyMappingMethods *tp_as_mapping; // ... /* Functions to access object as input/output buffer */ PyBufferProcs *tp_as_buffer; // ...&#125; PyTypeObject; 字段 tp_as_number 非空，因此 float 对象 支持数值型操作 ； 字段 tp_as_sequence 为空，因此 float 对象 不支持序列型操作 ； 字段 tp_as_mapping 为空，因此 float 对象 不支持关联型操作 ；","categories":[{"name":"Python","slug":"Python","permalink":"http://taizilongxu.github.io/wiki/categories/Python/"}],"tags":[]},{"title":"List","slug":"Python/pythonList","date":"2020-03-28T17:45:08.000Z","updated":"2020-03-28T17:45:08.000Z","comments":true,"path":"wiki/Python/pythonList/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Python/pythonList/","excerpt":"","text":"常用方法 方法 备注 list.append(obj) 单个元素用 append list.count(obj) list.extend(seq) 通常用 + 代替, list + list list.insert(index, obj) list.pop([index=-1]) list.remove(obj) list.reverse() list[::-1] list.sort(cmp=None, key=None, reverse=False) list.sort( key=lambda r: r[2]) 结构代码位置: Include/floatobject.h 123456789101112131415161718typedef struct &#123; PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for 'allocated' elements. The number * currently in use is ob_size. * Invariants: * 0 &lt;= ob_size &lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated;&#125; PyListObject; ob_size: 列表实际大小 allocated: 内存分配大小 Type 类型代码位置: Objects/listobject.c 123456789101112PyTypeObject PyList_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) \"list\", sizeof(PyListObject), 0, (destructor)list_dealloc, /* tp_dealloc */ ... (initproc)list___init__, /* tp_init */ PyType_GenericAlloc, /* tp_alloc */ PyType_GenericNew, /* tp_new */ PyObject_GC_Del, /* tp_free */&#125;; 创建对象调用链: PyType_GenericNew -&gt; PyType_GenericAlloc -&gt; PyObject_INIT_VAR 猜测因为 List 主要存储为动态数组, 内部结构直接使用 Generic 初始化了 C 接口代码位置: Objects/listobject.c 1234567891011121314151617181920212223242526272829303132333435363738PyObject *PyList_New(Py_ssize_t size)&#123; PyListObject *op; if (size &lt; 0) &#123; PyErr_BadInternalCall(); return NULL; &#125; // numfree 总共80个 list 对象数组, 可以共享 if (numfree) &#123; numfree--; op = free_list[numfree]; _Py_NewReference((PyObject *)op); &#125; else &#123; op = PyObject_GC_New(PyListObject, &amp;PyList_Type); if (op == NULL) return NULL; &#125; if (size &lt;= 0) op-&gt;ob_item = NULL; else &#123; op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *)); if (op-&gt;ob_item == NULL) &#123; Py_DECREF(op); return PyErr_NoMemory(); &#125; &#125; Py_SET_SIZE(op, size); op-&gt;allocated = size; _PyObject_GC_TRACK(op); return (PyObject *) op;&#125;#ifndef PyList_MAXFREELIST#define PyList_MAXFREELIST 80#endifstatic PyListObject *free_list[PyList_MAXFREELIST]; 总结 本质是动态数组 列表最大为 1 &lt;&lt; 64 每次 append 会判断空间是否足够, 扩展办法: 1234/* cpython/Objects/listobject.c *//* 空间增长的规律是: 0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ... *//* 当前的: new_allocated = 5 + (5 &gt;&gt; 3) + 3 = 8 */new_allocated = (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6); 使用 pop 方法时每次都会调用 resize 函数, 但是只有新申请空间比当前已有空间一半还小的时候被调用 123456789101112/* cpython/Objects/listobject.c *//* allocated: 8, newsize: 3, 8 &gt;= 3 &amp;&amp; (3 &gt;= 4?), 已经比一半还小了 */if (allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; 1)) &#123; /* 如果当前空间没有比原空间一半还小 */ assert(self-&gt;ob_item != NULL || newsize == 0); /* 只更改 ob_size 这个字段里的值即可 */ Py_SIZE(self) = newsize; return 0;&#125;/* ... *//* 3 + (3 &gt;&gt; 3) + 3 = 6 */new_allocated = (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);","categories":[{"name":"Python","slug":"Python","permalink":"http://taizilongxu.github.io/wiki/categories/Python/"}],"tags":[]},{"title":"unicode 和 UTF-8","slug":"杂项/unicode","date":"2020-03-25T17:11:43.000Z","updated":"2020-05-27T13:21:18.222Z","comments":true,"path":"wiki/杂项/unicode/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/%E6%9D%82%E9%A1%B9/unicode/","excerpt":"","text":"参考资料: http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html https://www.edc4it.com/blog/general/character-encoding-unicode-utf-8-and-a-bit-of-chauvinism-explained-for-the-masses-2 BOMByte order Mark 标记文本大小端 UTF-8 不需要 BOM, 因为本身编码机制可以识别 UTF-16 和 UTF-32 需要 BOM BOM 存在于微软系统中, Linux, Mac 无需考虑","categories":[{"name":"杂项","slug":"杂项","permalink":"http://taizilongxu.github.io/wiki/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"Python2 编码错误汇总","slug":"Python/pythonStringError","date":"2020-03-24T18:00:57.000Z","updated":"2020-03-24T18:01:26.000Z","comments":true,"path":"wiki/Python/pythonStringError/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Python/pythonStringError/","excerpt":"","text":"","categories":[{"name":"Python","slug":"Python","permalink":"http://taizilongxu.github.io/wiki/categories/Python/"}],"tags":[]},{"title":"Int","slug":"Python/pythonInt","date":"2020-03-21T05:02:06.000Z","updated":"2020-04-03T18:07:57.000Z","comments":true,"path":"wiki/Python/pythonInt/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Python/pythonInt/","excerpt":"","text":"参考资料: https://he11olx.com/2018/07/14/1.CPython3.6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.1.Python%E6%95%B4%E6%95%B0%E5%AF%B9%E8%B1%A1/ https://flaggo.github.io/python3-source-code-analysis/objects/long-object/ https://rushter.com/blog/python-integer-implementation/ 结构代码位置: Include/longintrepr.h 1234struct _longobject &#123; PyObject_VAR_HEAD digit ob_digit[1]; // digit 与平台相关，长度不一致&#125;; 存储格式SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i) 例如 9223372043297226753 可以表示为$$1 * (2^{30})^0 + 6 * (2^{30})^1 + 8 *(2^{30})^2$$在 Python 内部表示为ob_size: 3 ob_digit: [1, 6, 8] Pylong_SHIFT: 30 关于 PyLong_SHIFT 取值原因 Type 类型代码位置: Objects/longobject.c 123456789101112PyTypeObject PyLong_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) \"int\", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ ... &amp;long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ long_new, /* tp_new */ PyObject_Del, /* tp_free */&#125;; New 初始化代码位置: Objects/clinic/longobject.c.h 123456789101112131415161718192021static PyObject *long_new_impl(PyTypeObject *type, PyObject *x, PyObject *obase);static PyObject *long_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)&#123; PyObject *return_value = NULL; static const char * const _keywords[] = &#123;\"\", \"base\", NULL&#125;; static _PyArg_Parser _parser = &#123;\"|OO:int\", _keywords, 0&#125;; PyObject *x = NULL; PyObject *obase = NULL; if (!_PyArg_ParseTupleAndKeywordsFast(args, kwargs, &amp;_parser, &amp;x, &amp;obase)) &#123; goto exit; &#125; return_value = long_new_impl(type, x, obase);exit: return return_value;&#125; 代码位置: Objects/longobject.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344static PyObject *long_new_impl(PyTypeObject *type, PyObject *x, PyObject *obase)/*[clinic end generated code: output=e47cfe777ab0f24c input=81c98f418af9eb6f]*/&#123; Py_ssize_t base; if (type != &amp;PyLong_Type) return long_subtype_new(type, x, obase); /* Wimp out */ if (x == NULL) &#123; if (obase != NULL) &#123; PyErr_SetString(PyExc_TypeError, \"int() missing string argument\"); return NULL; &#125; return PyLong_FromLong(0L); &#125; if (obase == NULL) return PyNumber_Long(x); base = PyNumber_AsSsize_t(obase, NULL); if (base == -1 &amp;&amp; PyErr_Occurred()) return NULL; if ((base != 0 &amp;&amp; base &lt; 2) || base &gt; 36) &#123; PyErr_SetString(PyExc_ValueError, \"int() base must be &gt;= 2 and &lt;= 36, or 0\"); return NULL; &#125; if (PyUnicode_Check(x)) return PyLong_FromUnicodeObject(x, (int)base); else if (PyByteArray_Check(x) || PyBytes_Check(x)) &#123; char *string; if (PyByteArray_Check(x)) string = PyByteArray_AS_STRING(x); else string = PyBytes_AS_STRING(x); return _PyLong_FromBytes(string, Py_SIZE(x), (int)base); &#125; else &#123; PyErr_SetString(PyExc_TypeError, \"int() can't convert non-string with explicit base\"); return NULL; &#125;&#125; x == NULL 且 obase != NULL 调用 PyLong_FromLong obase 为 NULL 调用 PyNumber_Long x 和 obase 都不为 NULL PyUnicode 调用 PyLong_FromUnicodeObject，最终调用 PyLong_FromString PyByteArray/PyBytes 调用_PyLong_FromBytes，最终调用 PyLong_FromString C 接口代码位置: Include/longobject.h 1234567891011PyObject* PyLong_FromLong(long v)PyObject* PyLong_FromUnsignedLong(unsigned long v)PyObject* PyLong_FromSsize_t(Py_ssize_t v)PyObject* PyLong_FromSize_t(size_t v)PyObject* PyLong_FromLongLong(long long v)PyObject* PyLong_FromUnsignedLongLong(unsigned long long v)PyObject* PyLong_FromDouble(double v)PyObject* PyLong_FromString(const char *str, char **pend, int base)PyObject* PyLong_FromUnicode(Py_UNICODE *u, Py_ssize_t length, int base)PyObject* PyLong_FromUnicodeObject(PyObject *u, int base)PyObject* PyLong_FromVoidPtr(void *p) 代码位置: Objects/longobject.c 12345678910111213141516171819202122232425PyObject *PyLong_FromLong(long ival)&#123; PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so &gt;&gt; doesn't propagate sign bit */ int ndigits = 0; int sign; if (IS_SMALL_INT(ival)) &#123; return get_small_int((sdigit)ival); &#125; ... /* Fast path for single-digit ints */ if (!(abs_ival &gt;&gt; PyLong_SHIFT)) &#123; v = _PyLong_New(1); if (v) &#123; Py_SET_SIZE(v, sign); v-&gt;ob_digit[0] = Py_SAFE_DOWNCAST( abs_ival, unsigned long, digit); &#125; return (PyObject*)v; &#125;&#125; small_ints 数组长度，默认[-5, 256] 小整型会缓存, 只增加引用","categories":[{"name":"Python","slug":"Python","permalink":"http://taizilongxu.github.io/wiki/categories/Python/"}],"tags":[]},{"title":"Python Object","slug":"Python/pythonObject","date":"2020-03-19T17:28:04.000Z","updated":"2020-03-19T17:28:04.000Z","comments":true,"path":"wiki/Python/pythonObject/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Python/pythonObject/","excerpt":"","text":"资料: https://github.com/zpoint/CPython-Internals https://python.fasionchan.com/zh_CN/latest/source/object-model/pyobject.html https://blog.csdn.net/Lzs1998/article/details/103907147?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task 当前版本代码 123$ git clone https://github.com/python/cpython.git$ cd cpython$ git reset --hard 6672c16b1d7f83789bf3a2016bd19edfd3568e71 PyObject代码地址: Include/object.h 定长对象 12345typedef struct _object &#123; _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; struct _typeobject *ob_type;&#125; PyObject; _PyObject_HEAD_EXTRA: Debug 用, 可以忽略 ob_refnt: 引用计数, 垃圾回收使用 ob_type: 类型指针, 指向对象的类型对象 变长对象 1234typedef struct &#123; PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part */&#125; PyVarObject; PyTypeObject代码位置: Include/cpython/object.h 123456789101112131415161718typedef struct _typeobject &#123; PyObject_VAR_HEAD const char *tp_name; /* For printing, in format \"&lt;module&gt;.&lt;name&gt;\" */ Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ /* Methods to implement standard operations */ destructor tp_dealloc; printfunc tp_print; getattrfunc tp_getattr; setattrfunc tp_setattr; // ... /* Attribute descriptor and subclassing stuff */ struct _typeobject *tp_base; // ......&#125; PyTypeObject; tp_name: 类型名称 tp_basicsize, tp_itemsize: 创建实例对象所需内存信息 tp_print, tp_getattr: 该类型支持的相关操作信息 PyType_Type(type)代码位置: Objects/typeobject.c 123456789101112PyTypeObject PyType_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) \"type\", /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ (destructor)type_dealloc, /* tp_dealloc */ // ... (reprfunc)type_repr, /* tp_repr */ // ...&#125;; 内建类型和自定义类对应的 PyTypeObject 都是通过 PyTypeType 创建的, 被称作 元类型(meta class) PyType_Type 将自己的 ob_type 设置成自己 PyBaseObject_Type(object)代码位置: Objects/typeobject.c 12345678910PyTypeObject PyBaseObject_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) \"object\", /* tp_name */ sizeof(PyObject), /* tp_basicsize */ 0, /* tp_itemsize */ object_dealloc, /* tp_dealloc */ // ... object_repr, /* tp_repr */&#125;; 总结 Type 是所有实例化对象的爸爸 Object 是为了确认类和父类的关系在创建对象时 创建对象过程pi = float(&#39;3.14&#39;) 通过 Python 的 interpreter 我们可以翻译出这个语句是实例化 float 的过程, 这个过程即 type 来统一创建对象的流程(可以通过学习 Cpython 加深理解) 调用 float ， Python 最终执行其类型对象 type 的 tp_call 函数； tp_call 函数调用 float 的 tp_new 函数为实例对象分配 内存空间 ； tp_call 函数必要时进一步调用 tp_init 函数对实例对象进行 初始化 ；","categories":[{"name":"Python","slug":"Python","permalink":"http://taizilongxu.github.io/wiki/categories/Python/"}],"tags":[]},{"title":"Cypthon","slug":"TODO/cpython","date":"2020-03-19T17:24:45.000Z","updated":"2020-03-19T17:24:45.000Z","comments":true,"path":"wiki/TODO/cpython/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/TODO/cpython/","excerpt":"","text":"目录 12345678910111213141516cpython &#x2F;│├── Doc ← Source for the documentation├── Grammar ← The computer-readable language definition├── Include ← The C header files├── Lib ← Standard library modules written in Python├── Mac ← macOS support files├── Misc ← Miscellaneous files├── Modules ← Standard Library Modules written in C├── Objects ← Core types and the object model├── Parser ← The Python parser source code├── PC ← Windows build support files├── PCbuild ← Windows build support files for older Windows versions├── Programs ← Source code for the python executable and other binaries├── Python ← The CPython interpreter source code└── Tools ← Standalone tools useful for building or extending Python","categories":[{"name":"TODO","slug":"TODO","permalink":"http://taizilongxu.github.io/wiki/categories/TODO/"}],"tags":[]},{"title":"","slug":"TODO/OOMKiller","date":"2020-03-13T11:56:41.104Z","updated":"2020-03-13T11:56:46.000Z","comments":true,"path":"wiki/TODO/OOMKiller/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/TODO/OOMKiller/","excerpt":"","text":"","categories":[{"name":"TODO","slug":"TODO","permalink":"http://taizilongxu.github.io/wiki/categories/TODO/"}],"tags":[]},{"title":"","slug":"TODO/BNF","date":"2020-03-13T10:06:09.270Z","updated":"2020-03-13T10:06:11.000Z","comments":true,"path":"wiki/TODO/BNF/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/TODO/BNF/","excerpt":"","text":"","categories":[{"name":"TODO","slug":"TODO","permalink":"http://taizilongxu.github.io/wiki/categories/TODO/"}],"tags":[]},{"title":"Nothing","slug":"TODO/scala","date":"2020-03-12T06:35:19.633Z","updated":"2020-03-12T07:01:43.000Z","comments":true,"path":"wiki/TODO/scala/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/TODO/scala/","excerpt":"","text":"","categories":[{"name":"TODO","slug":"TODO","permalink":"http://taizilongxu.github.io/wiki/categories/TODO/"}],"tags":[]},{"title":"","slug":"TODO/ssd","date":"2020-03-09T06:47:52.000Z","updated":"2020-03-09T06:47:52.000Z","comments":true,"path":"wiki/TODO/ssd/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/TODO/ssd/","excerpt":"","text":"","categories":[{"name":"TODO","slug":"TODO","permalink":"http://taizilongxu.github.io/wiki/categories/TODO/"}],"tags":[]},{"title":"基本数据类型","slug":"Language/Java/base/base","date":"2020-03-08T10:09:30.021Z","updated":"2020-03-08T15:56:07.869Z","comments":true,"path":"wiki/Language/Java/base/base/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Language/Java/base/base/","excerpt":"","text":"资料 https://zhuanlan.zhihu.com/p/28654272 简单类型 封装器类 二进制位数 byte Byte 8 short Short 16 int Integer 32 long Long 64 float Float 32 double Double 64 char Character 16 boolean Boolean 1","categories":[{"name":"Language","slug":"Language","permalink":"http://taizilongxu.github.io/wiki/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/"},{"name":"base","slug":"Language/Java/base","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/base/"}],"tags":[]},{"title":"Collection","slug":"Language/Java/base/collection","date":"2020-03-08T09:55:29.562Z","updated":"2020-03-09T07:52:46.283Z","comments":true,"path":"wiki/Language/Java/base/collection/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Language/Java/base/collection/","excerpt":"","text":"资料 https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/ https://blog.csdn.net/u013309870/article/details/71478120 [https://blog.timberliu.com/2019/02/19/024_Java%E9%9B%86%E5%90%88%E4%B9%8B%20%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/](https://blog.timberliu.com/2019/02/19/024_Java集合之 总体架构/) List有序列表, 用特定的插入顺序来维护元素顺序 ArrayList动态数组(自动扩容), 随机访问效率高, 但插入和删除效率低, 有一个初始容量(10), 代表数组的大小, 在快满时进行扩容操作, 每次增长 1.5 倍大小 LinkedList双向链表, 不支持随机访问, 但容易进行删除和插入 因为是双向链表, 在通过 index 获取元素时可以以 O(n/2) 的复杂度获取 Vector与 ArrayList 相似, 基于动态数组, 区别就是它是同步的. Set不包含重复元素, 内部通过 Map 实现 HashSet: 底层基于 HashMap 实现, 内部顺序由哈希码决定, 可以放入 null TreeSet: 底层基于 TreeMap 实现, 以某种排序规则排序. 它是使用元素的自然顺序排序, 或根据创建 Set 时提供的 Comparator 进行排序. 但不允许存入 null 值 Queue先进先出队列, 不允许随机访问 ArrayDeque 循环数组实现双端队列, 默认大小 16 PriorityQueue: 优先级队列, 用自然顺序或制定的比较器来排序. 队列的头是按指定排序方式的最小元素 Map键值对组成的集合, 提供 key 到 value 的映射 HashMap通过哈希函数将元素的哈希地址转换成数组索引, 出现碰撞冲突使用链表形式存储哈希地址相同的元素, 在 JDK8 后, 链表过长会转换为红黑树, 可以放入 null 重要参数: Initial capacity 初始容量(默认 16), 但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(3-&gt;4、7-&gt;8、9-&gt;16) Load factor 填满最大比例(默认 0.75) Hash 函数实现: 大概理解下即可, 比较 geek 的点是 h&gt;&gt;&gt;16 增加一下高位参与下标运算 Put 函数实现: 对key的hashCode()做hash，然后再计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD, 默认值为 8)，就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。 Get 函数实现: bucket里的第一个节点，直接命中； 如果有冲突，则通过key.equals(k)去查找对应的entry 若为树，则在树中通过key.equals(k)查找，O(logn)； 若为链表，则在链表中通过key.equals(k)查找，O(n)。 Resize 函数实现: 重点是理解每次 resize 都是2倍, 最后一步的 (n-1) &amp; hash 效率比较高 LinkedHashMap在 HashMap 的基础上增加双向链表的结构, 实时多加了 before, after 指针, 为了维护access-order 或者 insertion-order 利用 LinkedHashMap 以及用户定义的 removeEldestEntyry 方法可以实现 LRU 功能 TreeMap实现了 SortedMap 接口, 内部以红黑树实现, 键以某种排序规则排序, 也可以通过 Comparator 比较器指定","categories":[{"name":"Language","slug":"Language","permalink":"http://taizilongxu.github.io/wiki/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/"},{"name":"base","slug":"Language/Java/base","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/base/"}],"tags":[]},{"title":"homebrew","slug":"MacOS/homebrew","date":"2020-03-03T14:20:19.000Z","updated":"2020-03-07T02:45:39.998Z","comments":true,"path":"wiki/MacOS/homebrew/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/MacOS/homebrew/","excerpt":"","text":"参考资料: https://sspai.com/post/56009 核心概念 formula(s) 安装包的描述文件 cellar 安装软件所在目录 keg 具体某个包所在目录, keg 是 celear 的子目录 bottle 预先编译好的包, 直接安装不用编译(大多数) tap 下载源, 类似 repository cask 安装 macOS native 应用的扩展 bundle 描述 homebrew 依赖的扩展 架构 根目录: /usr/local 软件目录: /usr/local/Cellar Homebrew 目录: /usr/local/Homebrew 软链地址: /usr/local/bin cheat sheet Commands 命令 解释 brew install git 安装 brew uninstall git 卸载/移除 brew update git 升级 brew unlink git brew link git brew switch git 2.5.0 切换版本 brew list –versions git 查看已有版本 More package commands 命令 解释 brew info git 查看版本, 说明等 brew cleanup git 清除旧版本 brew edit git 修改描述 brew cat git 打印描述 brew home git 打开主页 brew search git 搜索安装包 Global commands 命令 解释 brew update 更新所有 brew list 查看所有安装包 brew outdate 待更新版本 brew doctor 自检 brew config 查看 brew 配置 Tap 命令 解释 brew tap 显示 tap brew tap homebrew/cask-cask 增加 tap Brew Cask commonds 命令 解释 brew cask install firefox 下载 firefox brew cask list 展示安装app brew cask update 升级app(注: 如果使用 brew cask 安装的软件最好不要用软件内部的升级) Service(mac 系统下通过 launchctl 管理进程) 命令 解释 brew services list 查看所有服务 brew services run mysql 运行服务 brew services start mysql 运行并开机自动运行 brew services stop mysql 停止服务 brew services restart mysql 重启服务 安装指定版本吐槽下这个功能, 作者脑袋有包 1234$ git clone git@github.com:Homebrew/homebrew-core.git$ cd homebrew-core$ git log master -- Formula/tmux.rb$ brew install https://raw.githubusercontent.com/Homebrew/homebrew-core/&lt;COMMIT-HASH&gt;/Formula/tmux.rb","categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://taizilongxu.github.io/wiki/categories/MacOS/"}],"tags":[]},{"title":"下载原理","slug":"Network/download","date":"2020-02-19T16:30:22.000Z","updated":"2020-03-06T18:51:40.865Z","comments":true,"path":"wiki/Network/download/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Network/download/","excerpt":"","text":"资料: https://fenying.gitbooks.io/bittorrent-specification-chinese-edition/chapter1.html BitTorrent核心概念 Tracker: 收集下载信息的服务器 Seed: 完整下载并且上传分享的用户 Leecher: 同时下载和上传的用户 Peer: 一切参与下载(上传)活动的 BT 客户端 Piece: 一个 piece 是一个下载单元, 每个 piece 都有独立的 SHA1 校验码 Block: 下载时从 peer 处传来的一段段数据, 一个或多个 block 构成一个 piece DHT(Distributed Hash Table)网络: 无 Tacker 下载 Torrent 文件结构torrent 有自己的编码格式 bencode MagnetMagnet URI scheme(磁力链接): 通过散列值来识别, 搜多文档 1magnet:?xt&#x3D;urn:btih:235768818BB1A8292310E8EE66DCBE402134B9C1","categories":[{"name":"Network","slug":"Network","permalink":"http://taizilongxu.github.io/wiki/categories/Network/"}],"tags":[]},{"title":"欢迎来到我的 Wiki","slug":"index","date":"2020-02-18T13:45:07.000Z","updated":"2020-02-18T13:45:07.000Z","comments":true,"path":"wiki/index/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/index/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"chroot","slug":"Linux/container/chroot","date":"2020-02-11T17:28:04.000Z","updated":"2020-02-11T17:28:04.000Z","comments":true,"path":"wiki/Linux/container/chroot/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Linux/container/chroot/","excerpt":"","text":"chroot = change root directory 限制根目录, 防止越权","categories":[{"name":"Linux","slug":"Linux","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/"},{"name":"container","slug":"Linux/container","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/container/"}],"tags":[]},{"title":"Linux namespace","slug":"Linux/container/namespace","date":"2020-02-11T17:20:00.000Z","updated":"2020-02-11T17:20:00.000Z","comments":true,"path":"wiki/Linux/container/namespace/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Linux/container/namespace/","excerpt":"","text":"参考资料: https://creaink.github.io/post/Computer/Linux/Linux-namespace.html https://draveness.me/docker Linux namespace 是 Linux 提供的一种内核级别环境隔离方法 分类 namespace 隔离内容 flag 内核 UTS 主机名 CLONE_NEWUTS Linux 2.4.19 IPC 进程间通信 CLONE_NEWIPC Linux 2.6.19 PID chroot 进程树 CLONE_NEWPID Linux 2.6.19 NS(Mount) 挂载点 CLONE_NEWNS Linux 2.6.24 NET 网络访问, 包括接口 CLONE_NEWNET Linux 2.6.29 USER 蒋虚拟的本地 UID 映射到真实的 UID CLONE_NEWUSER Linux 3.8 三个系统调用 clonne() 类似 fork, 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。 unshare() 使某进程脱离某个namespace setns() 把某进程加入到某个namespace 实操/proc/[pid]/ns/ 目录下包含了某个进程的 namespace 所属，在 shell 中 $$ 为当前进程 PID 所以可以： 1234567891011121314$ ls -l /proc/$$/nstotal 0lrwxrwxrwx 1 root root 0 Jan 5 00:13 cgroup -&gt; cgroup:[4026531835]lrwxrwxrwx 1 root root 0 Jan 4 06:18 ipc -&gt; ipc:[4026531839]lrwxrwxrwx 1 root root 0 Jan 4 06:18 mnt -&gt; mnt:[4026531840]lrwxrwxrwx 1 root root 0 Jan 4 06:18 net -&gt; net:[4026531957]lrwxrwxrwx 1 root root 0 Jan 4 06:18 pid -&gt; pid:[4026531836]lrwxrwxrwx 1 root root 0 Jan 4 06:18 user -&gt; user:[4026531837]lrwxrwxrwx 1 root root 0 Jan 4 06:18 uts -&gt; uts:[4026531838]$ readlink /proc/$$/ns/utsuts:[4026531838]$ readlink /proc/$PPID/ns/utsuts:[4026531838] /proc/[pid]/mounts 目录展现了进程的挂载点，而 /proc/[pid]/mountinfo 里的内容更详细。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/"},{"name":"container","slug":"Linux/container","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/container/"}],"tags":[]},{"title":"cgroup","slug":"Linux/container/cgroup","date":"2020-02-11T16:19:19.000Z","updated":"2020-02-11T16:19:19.000Z","comments":true,"path":"wiki/Linux/container/cgroup/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Linux/container/cgroup/","excerpt":"","text":"参考资料: https://tech.meituan.com/2015/03/31/cgroups.html https://blog.csdn.net/zsj100213/article/details/89088446 http://www.manongjc.com/article/7475.html https://zhuanlan.zhihu.com/p/81668069 由来cgroups(contol groups), google 工程师提出, 整合进 Linux 内核, 是 LXC 的基础 作用 限制单个进程或多个进程使用资源, 可以对 cpu, mem 实现精细化的控制 资源限制 优先级分配 资源统计 任务控制 整体框架 Filesystem: 类似于 /proc subsystem: 可配置资源, 例如 cpu, mem task: 进程在 cgroup 里称为 task, taskid 为 pid libcgroup: 开源软件, 方便配置 说明: 第一层为 subsystem, 对应不通的物理资源 第二层为 cgroup 结构体, 描述对应子系统的资源占用 css_set(cgroup subststem set) 辅助数据结构, 描述所有资源限制 P 进程, 一个进程对应一个 css_set 实操查看挂载点 123456789101112$ mount | grep cgrouptmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755) # tmpfs 内存临时文件呢cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls)cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory) 查看子系统 1234567891011121314$ ll /sys/fs/cgrouptotal 0drwxr-xr-x 5 root root 0 Nov 17 2018 blkiolrwxrwxrwx 1 root root 11 Nov 17 2018 cpu -&gt; cpu,cpuacctlrwxrwxrwx 1 root root 11 Nov 17 2018 cpuacct -&gt; cpu,cpuacctdrwxr-xr-x 8 root root 0 Nov 17 2018 cpu,cpuacctdrwxr-xr-x 3 root root 0 Nov 17 2018 cpusetdrwxr-xr-x 5 root root 0 Nov 17 2018 devicesdrwxr-xr-x 4 root root 0 Nov 17 2018 freezerdrwxr-xr-x 3 root root 0 Nov 17 2018 hugetlbdrwxr-xr-x 8 root root 0 Nov 17 2018 memorydrwxr-xr-x 3 root root 0 Nov 17 2018 net_clsdrwxr-xr-x 3 root root 0 Nov 17 2018 perf_eventdrwxr-xr-x 5 root root 0 Nov 17 2018 systemd 查看进程 cgroup 1234567891011$ cat /proc/135/cgroup10:memory:/9:cpuset:/8:hugetlb:/7:perf_event:/6:net_cls:/5:freezer:/4:blkio:/3:cpuacct,cpu:/2:devices:/1:name=systemd:/ 内存限制123$ cat /sys/fs/cgroup/memory/memory.oom_controloom_kill_disable 0under_oom 0 oom_kill_disable == 1: 程序进入休眠状态 oom_kill_disable == 0: 操作系统杀死 配置项 名称 作用 memory.usage_in_bytes 当前内存中的使用量 memory.memsw.usage_in_bytes 当前内存和交换空间中的使用量 memory.limit_in_bytes 设置or查看内存使用量 memory.memsw.limit_in_bytes 设置or查看 内存加交换空间使用量 memory.failcnt 查看内存使用量被限制的次数 memory.memsw.failcnt 查看内存和交换空间使用量被限制的次数 memory.max_usage_in_bytes 查看内存最大使用量 memory.memsw.max_usage_in_bytes 查看最大内存和交换空间使用量 memory.soft_limit_in_bytes 设置or查看内存的soft limit memory.stat 统计信息 memory.use_hierarchy 设置or查看层级统计的功能 memory.force_empty 触发强制page回收 memory.pressure_level 设置内存压力通知 memory.swappiness 设置or查看vmscan swappiness 参数 memory.move_charge_at_immigrate 设置or查看 controls of moving charges memory.oom_control 设置or查看内存超限控制信息(OOM killer) memory.numa_stat 每个numa节点的内存使用数量 内核 mem 控制: memory.kmem.limit_in_bytes # 设置or查看 内核内存限制的硬限 memory.kmem.usage_in_bytes # 读取当前内核内存的分配 memory.kmem.failcnt # 读取当前内核内存分配受限的次数 memory.kmem.max_usage_in_bytes # 读取最大内核内存使用量 memory.kmem.tcp.limit_in_bytes # 设置tcp 缓存内存的hard limit memory.kmem.tcp.usage_in_bytes # 读取tcp 缓存内存的使用量 memory.kmem.tcp.failcnt # tcp 缓存内存分配的受限次数 memory.kmem.tcp.max_usage_in_bytes # tcp 缓存内存的最大使用量 CPU 限制 cpuset 以核心的方式进行隔离 cpuquota 以 cpu 使用比率限制, 保证比率上限 cpusharess 以权重比率弹性分配, 保证最低占用时间比率 123456789101112131415161718[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu]$ lltotal 0-rw-r--r-- 1 root root 0 Nov 17 2018 cgroup.clone_children--w--w--w- 1 root root 0 Nov 17 2018 cgroup.event_control-rw-r--r-- 1 root root 0 Nov 17 2018 cgroup.procs-r--r--r-- 1 root root 0 Nov 17 2018 cgroup.sane_behavior-r--r--r-- 1 root root 0 Nov 17 2018 cpuacct.stat-rw-r--r-- 1 root root 0 Nov 17 2018 cpuacct.usage-r--r--r-- 1 root root 0 Nov 17 2018 cpuacct.usage_percpu-rw-r--r-- 1 root root 0 Nov 17 2018 cpu.cfs_period_us-rw-r--r-- 1 root root 0 Nov 17 2018 cpu.cfs_quota_us-rw-r--r-- 1 root root 0 Nov 17 2018 cpu.rt_period_us-rw-r--r-- 1 root root 0 Nov 17 2018 cpu.rt_runtime_us-rw-r--r-- 1 root root 0 Nov 17 2018 cpu.shares-r--r--r-- 1 root root 0 Nov 17 2018 cpu.stat-rw-r--r-- 1 root root 0 Nov 17 2018 notify_on_release-rw-r--r-- 1 root root 0 Nov 17 2018 release_agent-rw-r--r-- 1 root root 0 Nov 17 2018 tasks 配置项 cpu: 统限制对CPU的访问，每个参数独立存在于cgroups虚拟文件系统的伪文件中 名称 作用 cpu.shares cgroup对时间的分配, 针对所有核。比如cgroup A设置的是1，cgroup B设置的是2，那么B中的任务获取cpu的时间，是A中任务的2倍 cpu.cfs_period_us 完全公平调度器的调整时间配额的周期, 取值范围 1ms - 1s cpu.cfs_quota_us 完全公平调度器的周期当中可以占用的时间, 取值范围 &gt; 1ms, 如为 -1 即为无限制 cpu.stat cpu.stat.nr_periods 进入周期的次数 cpu.stat.nr_throttled 运行时间被调整的次数 cpu.stat.throttled_time 用于调整的时间 cpuacct: 生成cgroup任务所使用的CPU资源报告，不做资源限制功能 名称 作用 cpuacct.usage 该cgroup中所有任务总共使用的CPU时间（ns纳秒） cpuacct.stat 该cgroup中所有任务总共使用的CPU时间，区分user和system时间 cpuacct.usage_percpu 该cgroup中所有任务使用各个CPU核数的时间 cpuset: 适用于分配独立的CPU节点和Mem节点，比如将进程绑定在指定的CPU或者内存节点上运行 名称 作用 cpuset.cpus 可以使用的cpu节点 cpuset.mems 可以使用的mem节点 cpuset.memory_migrate 内存节点改变是否要迁移 cpuset.cpu_exclusive 此cgroup里的任务是否独享cpu cpuset.mem_exclusive 此cgroup里的任务是否独享mem节点 cpuset.mem_hardwall 限制内核内存分配的节点（mems是用户态的分配） cpuset.memory_pressure 计算换页的压力 cpuset.memory_spread_page 将page cache分配到各个节点中，而不是当前内存节点 cpuset.memory_spread_slab 将slab对象(inode和dentry)分散到节点中 cpuset.sched_load_balance 打开cpu set中的cpu的负载均衡 cpuset.sched_relax_domain_level the searching range when migrating tasks cpuset.memory_pressure_enable0d 是否需要计算 memory_pressure cgroup 与 systemd 关系其实没啥关系, 但是 systemd 兼容 cgroup, 可以在 cgroup 之上启动","categories":[{"name":"Linux","slug":"Linux","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/"},{"name":"container","slug":"Linux/container","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/container/"}],"tags":[]},{"title":"虚拟文件系统","slug":"TODO/vfs","date":"2020-02-09T15:54:44.180Z","updated":"2020-02-09T15:55:23.000Z","comments":true,"path":"wiki/TODO/vfs/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/TODO/vfs/","excerpt":"","text":"","categories":[{"name":"TODO","slug":"TODO","permalink":"http://taizilongxu.github.io/wiki/categories/TODO/"}],"tags":[]},{"title":"CFS 调度算法","slug":"Linux/cfs","date":"2020-02-06T17:24:48.000Z","updated":"2020-02-06T17:24:48.000Z","comments":true,"path":"wiki/Linux/cfs/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Linux/cfs/","excerpt":"","text":"参考: https://blog.acean.vip/post/linux-kernel/gai-shu-linuxnei-he-san-jia-ma-che-zhi-jin-cheng-guan-li Completely Fair Scheduler: 完全公平调度器 核内调度 只处理 TASK_RUNINNG 状态的 task_struct 只针对 normal 线程 算法关键: 红黑树 vtime = ptime * 1024 / weight ptime 为实际执行时间, weight 为 权重, 跟你 nice 值对应","categories":[{"name":"Linux","slug":"Linux","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/"}],"tags":[]},{"title":"Linux boot","slug":"Linux/boot","date":"2020-02-06T07:43:40.000Z","updated":"2020-03-10T15:07:45.346Z","comments":true,"path":"wiki/Linux/boot/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Linux/boot/","excerpt":"","text":"参考资料: http://www.nixhacker.com/explaining-the-magic-of-mbr-and-its/ http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html BIOS: Basic Input/Output System 硬件检测, 自检完后找到 MBR 移交执行 MBR: Master Boot Record GRUB: Grand Unified Bootloader 负责选择多个系统 img Kernal: Linux kenel 内核启动 init: 启动各种程序 BIOS &amp; UEFI 1980s 开始 BIOS 系统 应对 BIOS 限制, 2006 年 Intel 开发 EFI, 苹果采用 2007 年 UEFI 问世, 统一标准 MBRGPT, 配合 UEFI 食用```12345678910111213141516MBR:* 优点: 简单* 缺点: 只能 4 个分区, 不能识别大于 2T 的分区硬盘第一块 secotr 即为 MBR, 一般 512 bytes&#96;&#96;&#96;shellsudo xxd -g 1 &#x2F;dev&#x2F;sda | head -400000000: eb 63 90 10 8e d0 bc 00 b0 b8 00 00 8e d8 8e c0 .c..............0000010: fb be 00 7c bf 00 06 b9 00 02 f3 a4 ea 21 06 00 ...|.........!..0000020: 00 be be 07 38 04 75 0b 83 c6 10 81 fe fe 07 75 ....8.u........u0000030: f3 eb 16 b4 02 b0 01 bb 00 7c b2 80 8a 74 01 8b .........|...t..0000040: 4c 02 cd 13 ea 00 7c 00 00 eb fe 00 00 00 00 00 L.....|......... MBR 结构: Bootloader boot.img: 严格占有 446 bytes, 主要作用就是调用 BIOS 来加载 core.img 的 sector 到内存 core.img: 写入位于 MBR 和第一分区之间的部分, 在 32256 bytes 以下, 并不用占满, 主要是 GRUB 的内核, 加载后掌握控制权 /boot/grub: 一些 grub 配置文件 KernalBootloader 进行 Kernal 的 img 镜像加载解压缩, 并给予控制权, 最后调用 init 进行其他启动 System V &amp; Systemdkernal 会调用 /sbin/init 来启动 uid 为 1 的守护进程, 有两种选择 System V: 注意这个启动是串行, 很少在用, 感兴趣可以了解下, 命令 service Upstart: 基于事件机制 Systemd(地址会软链到/lib/systemd/systemd): 兼容 System V System V Systemd配置地址: /lib/systemd/system : 系统自带或程序自带安装地址 /etc/systemd/system: 用户自定义, 可覆盖上面文件夹内容 概念说明: target: target 也属于 Unit 一种, 是 Unit 的逻辑集合(和 System V 的运行级别概念相同), 同时还有个 *.target.wants 文件放置它所管理的 Unit Unit: 最小单元, 分几种类型的资源, 例如 device, mount, target 和我们最常用的 service 上图启动 garphitcal.target 执行的依赖 常用命令: 123456789101112131415161718192021# 常用$ systemctl status/start/restart/stop/reload &lt;service&gt;# 列出所有正在运行的, 类型为 service 的 Unit$ systemctl list-units --type=service# 查看依赖$ systemctl list-dependencies &lt;service&gt;# 查看配置文件$ systemctl cat &lt;service&gt;# 查看启动时的默认 Target$ systemctl get-default# 查看主机信息$ hostnamectl# 查看当前登录用户$ loginctl list-sessions$ loginctl list-users 日志管理: 12345678910111213141516171819202122# 查看内核日志（不显示应用日志）$ sudo journalctl -k# 滚动查看$ sudo jounalctl -f# 查看指定进程的日志$ sudo journalctl _PID=1# 查看某个路径的脚本的日志$ sudo journalctl /usr/bin/bash# 查看某个 Unit 的日志$ sudo journalctl -u nginx.service$ sudo journalctl -u nginx.service --since today# 查看指定时间的日志$ sudo journalctl --since=\"2012-10-30 18:17:16\"$ sudo journalctl --since \"20 min ago\"$ sudo journalctl --since yesterday$ sudo journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"$ sudo journalctl --since 09:00 --until \"1 hour ago\"","categories":[{"name":"Linux","slug":"Linux","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/"}],"tags":[]},{"title":"Cpython","slug":"TODO/saltstack","date":"2020-02-02T16:48:46.058Z","updated":"2020-03-13T05:59:22.000Z","comments":true,"path":"wiki/TODO/saltstack/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/TODO/saltstack/","excerpt":"","text":"http://pgbovine.net/cpython-internals.htm https://www.youtube.com/watch?v=HVUTjQzESeo https://tech.blog.aknin.name/category/my-projects/pythons-innards/","categories":[{"name":"TODO","slug":"TODO","permalink":"http://taizilongxu.github.io/wiki/categories/TODO/"}],"tags":[]},{"title":"","slug":"TODO/ansible","date":"2020-02-02T16:48:36.601Z","updated":"2020-03-12T06:37:01.000Z","comments":true,"path":"wiki/TODO/ansible/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/TODO/ansible/","excerpt":"","text":"","categories":[{"name":"TODO","slug":"TODO","permalink":"http://taizilongxu.github.io/wiki/categories/TODO/"}],"tags":[]},{"title":"switch 破解原理","slug":"Hack/switch","date":"2020-01-31T18:16:27.000Z","updated":"2020-01-31T18:16:27.000Z","comments":true,"path":"wiki/Hack/switch/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Hack/switch/","excerpt":"","text":"教程: https://github.com/ln93/kosmos_chs_tutorial 漏洞: Nvidia Tegra X1 破解原理: https://media.ccc.de/v/c4.openchaos.2018.06.glitching-the-switch#t=49 破解原理简单版: https://www.youtube.com/watch?v=L3PPWVPg2WI&amp;vl=en 硬件参数: CPU: Tegra X1 T210 GPU: Nvidia Maxwell GPU RAM: 4GB LPDDRR4 大致破解原理: Tegra X1 有个 recovery 模式的漏洞, 这个是在和 switch 同样的硬件中发现的, 在 switch 里就是我们熟知的短接 这个漏洞主要利用 BootRom 启动的时候通过 USB 进行通讯 ![image-20200128012739143](/Users/limbo/Library/Application Support/typora-user-images/image-20200128012739143.png) USB 通讯有签名, 这个无法绕过 ![image-20200128020009026](/Users/limbo/Library/Application Support/typora-user-images/image-20200128020009026.png) 但是可以控制通信协议长度, 让复制到 DMA 的内存溢出, 占用堆栈的地址, 函数返回的 stack 地址就可以接收系统控制权了 破解过程: TF 卡里先写入我们要接管的程序 通过短接 switch 进入 RCM 模式 通过 USB 连接电脑或者手机(注入 RCM), 通过注入跳转到我们写好的 TF 卡里的程序","categories":[{"name":"Hack","slug":"Hack","permalink":"http://taizilongxu.github.io/wiki/categories/Hack/"}],"tags":[]},{"title":"编译原理","slug":"TODO/compiler","date":"2020-01-31T18:14:03.524Z","updated":"2020-01-31T18:17:39.000Z","comments":true,"path":"wiki/TODO/compiler/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/TODO/compiler/","excerpt":"","text":"","categories":[{"name":"TODO","slug":"TODO","permalink":"http://taizilongxu.github.io/wiki/categories/TODO/"}],"tags":[]},{"title":"Class 文件结构","slug":"Language/Java/class_bytes","date":"2020-01-22T09:30:11.000Z","updated":"2020-01-22T09:30:11.000Z","comments":true,"path":"wiki/Language/Java/class_bytes/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Language/Java/class_bytes/","excerpt":"","text":"参考: https://coolshell.cn/articles/9229.html http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/ 魔数0XCAFEBABE 版本号 常量池","categories":[{"name":"Language","slug":"Language","permalink":"http://taizilongxu.github.io/wiki/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/"}],"tags":[]},{"title":"docker internal","slug":"TODO/docker","date":"2020-01-22T09:29:30.607Z","updated":"2020-02-11T17:29:20.000Z","comments":true,"path":"wiki/TODO/docker/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/TODO/docker/","excerpt":"","text":"https://medium.com/@nagarwal/understanding-the-docker-internals-7ccb052ce9fe Docker 底层三大技术 union filesystem, cgroup, namespace","categories":[{"name":"TODO","slug":"TODO","permalink":"http://taizilongxu.github.io/wiki/categories/TODO/"}],"tags":[]},{"title":"shell","slug":"Linux/shell","date":"2020-01-21T12:13:35.000Z","updated":"2020-01-21T12:13:35.000Z","comments":true,"path":"wiki/Linux/shell/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Linux/shell/","excerpt":"","text":"Shell 原理系统提供 shell 给用户调用内核 执行过程: 读取用户键盘指令 分析命令，以命令名作为文件名，并将其它参数改造为系统调用 execve() 内部处理所要求的形式 终端进程调用 fork() 建立一个子进程 终端进程本身用系统调用 wait4() 来等待子进程完成(如果是后台命令，则不等待). 当子进程运行时调用 execve()，子进程根据文件名(即命令名)到目录中查找有关文件(这是命令解释程序构成的文件), 将它调入内存, 执行这个程序(解释这条命令) 如果命令末尾有&amp;号(后台命令符号), 则终端进程不用系统调用 wait4() 等待, 立即发提示符, 让用户输入下一个命令, 转 1 如果命令末尾没有 &amp; 号, 则终端进程要一直等待, 当子进程(即运行命令的进程)完成处理后终止, 向父进程(终端进程)报告, 此时终端进程醒来, 在做必要的判别等工作后, 终端进程发提示符, 让用户输入新的命令, 重复上述处理过程. 内置 Shell 命令 Shell navigation 包管理","categories":[{"name":"Linux","slug":"Linux","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/"}],"tags":[]},{"title":"Hello World","slug":"Blog/hello-world","date":"2020-01-20T16:16:20.000Z","updated":"2020-01-20T16:16:20.000Z","comments":true,"path":"wiki/Blog/hello-world/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Blog/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Blog","slug":"Blog","permalink":"http://taizilongxu.github.io/wiki/categories/Blog/"}],"tags":[]},{"title":"JVM Memory","slug":"Language/Java/jvm/jvm_mem","date":"2020-01-20T16:00:12.000Z","updated":"2020-05-21T13:30:15.677Z","comments":true,"path":"wiki/Language/Java/jvm/jvm_mem/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Language/Java/jvm/jvm_mem/","excerpt":"","text":"JVM 主要三个组成: Heap: 所有实例对象, 堆内空间无法扩展出现 OOM 异常 Young Generation(默认比例 8:1:1) Eden From Survivor To Survivor Old Generation Method Area(Non-Heap, PermGen, 永久代): 方法区存储类信息, 常量, 静态变量等数据, 线程共享区域, 方法区也会抛出 OOM Stack Java Stack: 每个方法执行的时候都会创建一个 stack frame, 保存局部变量, 操作栈,动态链接, 方法出口等, 如果线程请求栈的深度大于虚拟机允许深度, 抛出 stackoverflow 异常, 如果虚拟机栈可以动态扩展, 当无法申请内存是会抛出 OOM 异常 Native Method Stack: 存一些原生方法, C 库 参数配置 其他内存占用NIONIO使用java.nio.ByteBuffer.allocateDirect()方法分配内存，每次分配内存都会调用操作系统函数os::malloc()，所以，分配的内存是本机的内存而不是Java堆上的内存； 另外利用该方法产生的数据和网络、磁盘发生交互的时候都是在内核空间发生的，不需要复制到用户空间Java内存中，这种技术避免了Java堆和本机堆之间的数据复制；但是利用该方法生成的数据会作为Java堆GC的一部分来自动清理本机缓冲区。 异常","categories":[{"name":"Language","slug":"Language","permalink":"http://taizilongxu.github.io/wiki/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/"},{"name":"jvm","slug":"Language/Java/jvm","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/jvm/"}],"tags":[]},{"title":"crontab","slug":"Linux/crontab","date":"2020-01-15T12:12:26.000Z","updated":"2020-01-15T12:12:26.000Z","comments":true,"path":"wiki/Linux/crontab/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Linux/crontab/","excerpt":"","text":"123456789101112131415[xuxiao.xu@l-rtools1.ops.cna ~]$ cat /etc/crontabSHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed https://crontab.guru/","categories":[{"name":"Linux","slug":"Linux","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/"}],"tags":[]},{"title":"","slug":"BigData/Kafka/cheat_sheet","date":"2020-01-15T12:06:59.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/BigData/Kafka/cheat_sheet/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/BigData/Kafka/cheat_sheet/","excerpt":"","text":"","categories":[{"name":"BigData","slug":"BigData","permalink":"http://taizilongxu.github.io/wiki/categories/BigData/"},{"name":"Kafka","slug":"BigData/Kafka","permalink":"http://taizilongxu.github.io/wiki/categories/BigData/Kafka/"}],"tags":[]},{"title":"Maven 汇总","slug":"Language/Java/maven","date":"2020-01-15T12:06:59.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/Language/Java/maven/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Language/Java/maven/","excerpt":"","text":"Maven 是常用的 Java 构建工具, 以 POM 文件为中心, Maven 工作时的几个主要步骤 读取 pom.xml 下载依赖到本地 执行构建过程 执行插件 POMPOM - Project Object Model 具体可参见 官网 POM 介绍 依赖包管理 Maven 会递归下载 POM 文件中的依赖, 可以用 &lt;exclusions&gt; 进行排除 Maven 下载的依赖来自 3 个地方: 本地 %USER_HOME%/.m2 目录 中央仓库 远程库 理解 Lifecycle, Phase, Goal Lifecycle上面图里可以看到 Maven 自带 3 个 Lifecycle: default: 主要生命周期, 编译代码并处理打包项目 clean: 清理构建输出, 包括中间文件 site: 文档生成 Phasedefault 的 Lifecycle 包含了许多 phase, 常见如下, 完整可以查看 Lifecycle Referrence validate: 验证项目 compile: 编译代码 test: 测试 package: 将编译后代码打包 install: 安装到本地存储 deploy: 发布到远程仓库 当我们执行 mvn install 时, 实际会按照顺序执行前置的各个 phase, 例如 validate -&gt; compile -&gt; test -&gt; package -&gt; install 最终执行到 install GoalMaven 为插件提供了 Goal 来注册到各个 phase 进行执行 Maven 是如何组合这些过程的在 POM 中有一个 &lt;packaging&gt; 选项, 默认会是 jar, 这个 packaging 会绑定一些 goal 到各个 phase, 默认可查看 Plugin Bindings, 举个例子 jar 的默认绑定: Phase plugin:goal process-resources resources:resources compile compiler:compile process-test-resources resources:testResources test-compile compiler:testCompile test surefire:test package jar:jar install install:install deploy deploy:deploy Maven 在按照 lifecycle 进行运行的时候会执行各个 phase 中的 goal Scope如果我们想要在不同阶段对打包进行控制, 可以设置 scope 参数, 官网 对应不通的编译阶段我们可以参考下图 compile: 默认设置, 参与整个打包的周期 provided: 比如说我们提交 Flink 任务到集群里, 很多包集群是已经附带的, 我们就可以把该包设置成 provided, 减少打包体积 runtime: 这个一般用 jdbc 可以选填, 只有在运行时才需要 test: 测试阶段用到的包 system: 从本地引用包, 不会去仓库下载, 配合 systemPath 使用 对于依赖的传递, 可以举例: A - comiple -&gt; B - provided -&gt; C 或者A - comiple -&gt; B - test -&gt; C 时 A 将丢弃 C, 不会引用 下面是具体的引用传递: 资料 Maven 官网 Maven 教程","categories":[{"name":"Language","slug":"Language","permalink":"http://taizilongxu.github.io/wiki/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/"}],"tags":[]},{"title":"JVM 简介 (翻译)","slug":"Language/Java/jvm/jvm","date":"2020-01-15T12:06:59.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/Language/Java/jvm/jvm/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Language/Java/jvm/jvm/","excerpt":"","text":"https://www.guru99.com/java-virtual-machine-jvm.html 什么是 JVM ?Java Virtual Machine (JVM) 是提供 Java 代码和应用运行环境的引擎. 它可以将 Java 字节码转换成机器码. JVM 是 Java Run Environment (JRE) 的一部分. 在其他语言里, 编译器为特定的系统产生机器码, 然而, Java 编译器产生的代码直接提供给虚拟机, 就是我们熟知的 JVM JVM 如何工作首先, Java 代码编译成字节码. 这个字节码可以在不同的机器上解析. 字节码是介于主机系统和 Java 源码之间的中间语言. JVM 负责分配内存空间 JVM 架构让我们来了解下 JVM 的架构. 它包含了 classloader, memory area, execution egine 等. ClassLoader: 类加载器是一个加载类文件的子系统, 包括 3 个主要功能, Loading, Linking 和 Initialization Method Area: JVM 方法区保存像 metadata, 持久的运行池和代码方法 Heap: 所有的 Object, 他们相关的 instance 变量, 数组都存在 heap 里, 这些内存可以在不同线程间分享 JVM Language Stacks: 存储 local 变量, 和一部分结果. 每个线程都有自己的 JVM stack, 创建线程的同时它们也会被创建. 当一个方法被 invoke 时, 新的 frame 就会被创建, 当方法 invocation process 完成时也就会被删除. PC Registers: 保存正在执行的代码地址. 在 Java 中, 每个线程有自己的 PC register. Native Method Stacks: 保存原生库的地方. 通常都是其他语言的代码. Execution Engine: It is a type of software used to test hardware, software, or complete systems. The test execution engine never carries any information about the tested product. Native Method interface: 编程框架. 允许 Java 代码在 JVM 里调用库和原生应用. Native Method Libraries: Execution Engine 需要的一些原生库(C, C++) 代码编译和执行过程为了书写和执行一个软件, 你需要: Editor: 输入你的代码 Compile: 讲你的高级语言转换成机器语言 Linker: 将不同的程序文件合并在你的 main 程序里. Loader: 讲文件从硬盘里加载到 RAM 里. Loading 的过程是在执行代码的时候自动执行的 Execution: 通过操作系统和进程来执行你的代码 C 代码编译和执行过程为了理解 Java 编译过程, 先让我们简单看一下 C 语言是如何编译和链接的 假设你的 main 函数里调用了 f1 和 f2 两个函数. main 函数保存在 a1.c 文件里 f1 函数保存在 a2.c 文件里 f2 函数保存在 a3.c 文件里 所有文件, a1.c, a2.c 和 a3.c 通过 compiler 输出为机器码 下一步就是通过 linker 将所有这些 object 文件打包成一个 exe 文件 在程序运行期间, 一个 loader 程序将会把 a.exe load 进 Ram 里来执行 Java 代码在 JVM 里编译和执行让我们看看 Java 程序. 在你的 main 函数里有 f1 , f2 两个函数 main 方法存在 a1.java 文件 f1 存在 a2.java 文件 f2 存在 a3.java 文件 compiller 将会产出 3 个以 .class 命名的字节码文件. 不像 C, 没有 linking 的过程. JVM 存在于 RAM 中. 在执行期间, 使用 class loader 把 class 文件装载进 RAM, 下一步, execution engine 将会把字节码转换为机器码,这是在 compile 时候进行的. 这就是为什么相对来说 Java 运行的比较慢. NOTE: JIT 或者说 Just-in-time compiler 是 JVM 的一部分. It interprets part of the Byte Code that has similar functionality at the same time. 为什么 Java 既是解析又是编译语言?程序语言分类 高级语言: C++, Java 中等语言: C 低级语言: Assembly 最低级语言: 机器语言 compiler 可以将一个程序从一级语言转化为另一级语言, 例如将 C++ 转为机器语言 java compiler 将高级的 java 代码转换为字节码(也是一种机器码) interpreter 可以将同一级别的语言转化为相同级别的语言.例如 Java 程序转换为 C++ 在 Java 中 JIT 将字节码转换为机器码是相同语言级别的转换 所以, Java 既是解析又是编译语言 为什么 Java 慢?主要两个原因: 动态链接: 不像 C, Java 在运行时链接 运行时解析: 字节码是在运行时转换为机器码. 所以速度有所减慢","categories":[{"name":"Language","slug":"Language","permalink":"http://taizilongxu.github.io/wiki/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/"},{"name":"jvm","slug":"Language/Java/jvm","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/jvm/"}],"tags":[]},{"title":"Wi-Fi 协议","slug":"Computer/Hardware/wifi","date":"2020-01-15T12:06:59.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/Computer/Hardware/wifi/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Computer/Hardware/wifi/","excerpt":"","text":"名称 代号 年代 频段 带宽 802.11b Wi-Fi 1 1999 2.4 GHz 11 Mbps 802.11a Wi-Fi 2 1999 5 GHz 54 Mbps 802.11g Wi-Fi 3 2003 2.4 GHz 54 Mbps 802.11n Wi-Fi 4 2009 2.4 GHz / 5 GHz 450 Mbps 802.11ac Wi-Fi 5 2014 2.4 GHz / 5 GHz 866.7 Mbps 802.11ax Wi-Fi 6 2019 2.4 GHz / 5 GHz 1201 Mbps","categories":[{"name":"Computer","slug":"Computer","permalink":"http://taizilongxu.github.io/wiki/categories/Computer/"},{"name":"Hardware","slug":"Computer/Hardware","permalink":"http://taizilongxu.github.io/wiki/categories/Computer/Hardware/"}],"tags":[]},{"title":"硬盘接口","slug":"Computer/Hardware/Disk/interface","date":"2020-01-15T12:06:59.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/Computer/Hardware/Disk/interface/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Computer/Hardware/Disk/interface/","excerpt":"","text":"名称 总线 物理接口 协议 年份 带宽 理论速度 编码 SATA 1.0 SATA SATA AHCI 2003 1.5 Gb/s 150 MB/s 8 b / 10 b SATA 2.0 SATA SATA AHCI 2004 3 Gb/s 300 MB/s 8 b / 10 b SATA 3.0 SATA SATA AHCI 2009 6 Gb/s 600 MB/s 8 b / 10 b SATA Express(SATA 3.2) SATA SATA 2014 16 Gb/s 1969 MB/s 128 b / 130 b M.2 SATA SATA M.2 AHCI 2013 6 Gb/s 600 MB/s M.2 NVMe NVMe M.2 PCIe 2013 32 Gb/s 3200 MB/s 上面这个图有点问题, Technology 那一行的 SATA 都改为 AHCI","categories":[{"name":"Computer","slug":"Computer","permalink":"http://taizilongxu.github.io/wiki/categories/Computer/"},{"name":"Hardware","slug":"Computer/Hardware","permalink":"http://taizilongxu.github.io/wiki/categories/Computer/Hardware/"},{"name":"Disk","slug":"Computer/Hardware/Disk","permalink":"http://taizilongxu.github.io/wiki/categories/Computer/Hardware/Disk/"}],"tags":[]},{"title":"RAID","slug":"Computer/Hardware/Disk/raid","date":"2020-01-15T12:06:59.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/Computer/Hardware/Disk/raid/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Computer/Hardware/Disk/raid/","excerpt":"","text":"RAID是英文Redundant Array of Independent Disks的缩写, 即磁盘冗余阵列. RAID 0分散打在不同磁盘上, 写入速度 * n RAID 1镜像对考， 双写 RAID 5校验块分布在不同磁盘上, 易于扩展 Raid 6采用两种独立的校验算法 RAID 组合组合方式, 速度既快, 又有备份","categories":[{"name":"Computer","slug":"Computer","permalink":"http://taizilongxu.github.io/wiki/categories/Computer/"},{"name":"Hardware","slug":"Computer/Hardware","permalink":"http://taizilongxu.github.io/wiki/categories/Computer/Hardware/"},{"name":"Disk","slug":"Computer/Hardware/Disk","permalink":"http://taizilongxu.github.io/wiki/categories/Computer/Hardware/Disk/"}],"tags":[]},{"title":"Flink 如何工作的?","slug":"BigData/flink","date":"2019-12-17T12:19:05.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/BigData/flink/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/BigData/flink/","excerpt":"","text":"Flink 是如何工作的? 本文主要分为两个部分, 分别介绍 Flink 集群的启动和 Flink 任务如何运行在集群中(Stream 方式), 由于篇幅有限, 本文尽量不探讨具体的实现细节,但是比较重要的部分给予一定的说明, 更多的是让读者了解 Flink 内部的工作原理. Flink 在部署上主要分为两部分 JobManager 和 TaskManager, JobManager 主要负责任务的分发, slot 资源管理等, TaskManager 则主要负责任务的运行. 下面这张官网的架构图虽然年代有点久远, 但至今大部分功能还是如图所述. 从上面图中需要了解的信息: Flink 代码在客户端里进行了”编译”, 然后提交给 JobManager, 这里比较重要, 因为很多 Optimizer 的东西都可以在这里做 JobManager 拿到”编译”后的 job 再分发到各个 TaskManager 的 Slot 里 Flink 有两种通信方式, 远程调用使用的是 Actor, TaskManager 数据传输使用的是 Netty JobManager 集成了 Scheduler 和 Checkpoint Coordinator 等主要功能 1 Flink 集群的启动Flink 集群的启动方式主要分为以下 3 种: Standalone 方式: 最基础的方式, 具有完整的功能, 可在实体机上进行部署 Cluster session 方式: 部署在像 Yarn , K8s 等资源调度框架内, 直接建立起集群, 然后通过与 JobManager 交互来提交作业, 但是在实际生产过程中发现有严重的 Bug 还没有解决, 可参看 FLINK-11205 , 主要是 Metaspace 空间无法释放导致 TaskManager 被 kill, 而一个集群里存在多个 TaskManager 问题更加严重, 会导致整个集群 Taskmanager 不断重启. Per Job 方式: 在 Yarn 中已经很好的集成了这种方式, 就是整个集群的生命周期和任务进行绑定, 任务结束, 集群资源也随着撤销, 唯一的缺点就是部署时间上不如 Cluster session 的方式, 这点其实在实际生产中可以忽略. 1.1 JobManager 的启动因为版本变动的关系 Jobmanager 在 1.5 版本的时候进行了一次大改, 和上面的图可能略有不通, 具体可以参见 FLIP-6, 下面聊一聊一般生产中 JobManager 如何启动的. 上图可以看出在 1.5 以后的新版本中 JobManager 多出了两个组件, 一个是 ResourceManager, 主要负责管理 Flink 自己的 TaskManager 资源, 注意这个 ResourceManager 和 Yarn 上的不是同一个, 两者管理的资源不是同一级别, 第二个是 Dispatcher 主要是提供 client 的 RPC 接口, 提供发布任务的一系列功能. 而 JobMaster 主要负责一个任务的生命周期, 每个 Flink Job 都有一个 JobMaster 与之对应. 1.2 TaskManager 的启动TaskManager 其实功能比较简单, 提供一些基本的 RPC 服务, 供 JobManager 进行调度, 稍后会讲到 TaskManager 如何运行 JobManager 提供的 subTask. 2 Flink Job 的启动我们先来看看一个 Flink job 的构成 Flink job 最核心的构成其实就是这个 ENV, 用户需要通过调用 ENV 来注册用户的代码逻辑, 而这个 ENV 定义了一系列 DAG 生成的规则, 比如 env.addSource 我们必须指定 Source 的类型, 是 DataStream 还是 DataSet, 又比如 keyBy 之后返回的是 KeyedStream, 这些规则都是在 ENV 里进行了定义, 用户只要根据规则来使用即可, 而且根据 ENV 的定义我们可以在不同的环境中运行 Flink Job, 如下图所示: 我们可以以 Flink 开发者的角度思考如何从用户代码到底层实现, 这一过程必然使用分层结构, 下面来看一下各个层级的工作: 2.1 Client 端首先在 Client 端生成的第一层是 User Rule, 这个算是用户代码到 DAG 的第一层抽象, 这里面制定了很多规则, 来约束用户的行为, 引导用户更好的使用 Flink 程序. 第二层是 Transformation 层, 这里的 Transformation 主要是完成了对用户的各个算子的定义, 比如说 addSource 的操作即为 SourceTransformation, filter 操作即为 OneInputTransformation, 这里面与用户的算子一一对应, 但是这里面区分定义了 PhysicalTransformation, PhysicalTransformastion 可以理解为物理算子, 需要计算资源进行计算, 而 union, select 这些并非物理算子, 可以在后面的结构中通过网络 shuffle 进行合并, 在这一步我们得到的还是一个 Transformation 的列表, 完整的描述了用户定义的各个算子, 如下图所示: 第三层就是我们的 StreamGraph 了, 从 Transformation 转化而来, 构成了图的结构, 其中 StreamNode 为点, StreamEdge 为边, 在程序里存入的部分是一张链表结构, 如下图所示: 这里面加入了一些信息, 比如说 slotSharingGroup, 从而定义这些算子如何在 slot 里分配 在 Client 里生成的最后一层即为 JobGraph, 这也是 Flink JobManager 接收的任务对象, 其实上一层的 StreamGraph 已经完成了任务 DAG , 为什么还需要 JobGraph 呢, 其实是为了兼容 Batch 模式, JobGraph 作为统一层进行封装, 同时提供了计算优化即 setChain 功能, 可以减小序列化和网络开销, 可能有的同学会对 chain 的概念有所疑惑 , 比如说 map 算子后面接入一个 filter 算子, 而且是同等数量的, 这样我就可以把 map 和 filter 抽象成一个计算进行自动优化, 要达到 chain 的条件比较苛刻, 具体可以查看代码 在 JobGraph 里主要结构就是 JobVertex 和 JobEdge, 在前面所说的 chain 方法后, 可以合并 两个或多个 StreamNode 为一个 JobVertex, 如下图所示: 好了这里基本就聊完了 Client 端的工作 2.2 JobManager 端JobManager 端接收到 client 提交的 JobGraph, 根据 JobgRaph 来生成 ExcutionGraph, 这个 ExcutionGraph 简单来说就是 JobGraph 的并行版本, 定义具体执行的细节: 这里省略了一部分(其他部分一样), 主要来看看几个结构, ExecutionJobVertex 主要类似于 JobGraph 的 Node, 管理所有下面的并行状态, ExecutionVertex 是最小的执行单位(也是我们所说的 SubTask, 每个 SubTask 都由一个 thread 启动), 同理 IntermediateResult 负责多个 IntermediateResultPartition. 到这里完成了 ExecutionGraph, 而需要部署到 TaskManager 中间还需要为每个 Vertex 生成 TaskDeploymentDescriptor, 来描述在 TaskManager 中的具体任务, 比如 inputGates(输入), producedPartition(输出), 然后提交给 TaskManager 2.3 TaskManager 端上面提到 JobManager 生成 TaskDeploymentDescriptor 提交给 TaskManager, TaskManager 就比较好办了, 只需要设定这个 Task 的输入和输出还有 run 这个 Task 即可, 这一层就是所谓的物理执行层. 而对于分布在各个 TaskManager 上的 SubTask 是如何通信的呢, 可以看下图: 对于在同一个 TaskManager 内的 subTask, 通过 InputGate 和 ResultPartition 直接进行通信, 而对于不在同一个 TaskManager 里需要借助 Netty 层进行网络通信: 还有一点值得注意的是, 当有消息来到时 ResultPartition 会给 InputGate 发送 notifyDataAvallable, 告诉下游该来取数了, 如果下游比较忙没空来取的话就会阻塞, 进而逐级向上传导产生被压, 这种缓冲 buffer 的方式是 flink 天然处理被压的方法. 至此整个 Flink Job 的流程已经结束, 但毕竟 Flink 是一个庞大的开源项目, 很多细节比如 Checkpoint 机制, 状态存储这些重要的概念还未涉及, 有兴趣的读者可以参考优秀的 Blog 进一步研究 参考资料: Flink 官网 FLIP Jark’s Blog 玉兆的博客 Flink 官方博客","categories":[{"name":"BigData","slug":"BigData","permalink":"http://taizilongxu.github.io/wiki/categories/BigData/"}],"tags":[]},{"title":"黑苹果原理","slug":"Computer/Hackintosh/principel","date":"2019-12-08T12:19:05.000Z","updated":"2020-02-02T16:48:27.000Z","comments":true,"path":"wiki/Computer/Hackintosh/principel/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Computer/Hackintosh/principel/","excerpt":"","text":"原理操作系统正常启动方式为 UEFI 或者 BIOS, 苹果因为需要各种验证所以中间需要进行一层 mock, 就是常见的 Clover UEFI -&gt; Clover -&gt; Mac OS 所以说如果弄黑苹果最主要的是调整好苹果的 EFI 即可, 理论上可以无痛更新 https://github.com/daliansky/Hackintosh 收集各种型号主机的 EFI 配置 主板: B360i ROG CPU: i5-9600k 安装方法参考 黑果小兵 的博客, 目前为止见过最权威的博主了 根据 github 搜索 https://github.com/FisherWY/Asus-B360i-Hackintosh-EFI 按照教程一步步来即可 参考资料 关于黑苹果你必须要知道的事儿 tonymacx86","categories":[{"name":"Computer","slug":"Computer","permalink":"http://taizilongxu.github.io/wiki/categories/Computer/"},{"name":"Hackintosh","slug":"Computer/Hackintosh","permalink":"http://taizilongxu.github.io/wiki/categories/Computer/Hackintosh/"}],"tags":[]},{"title":"环境变量","slug":"Linux/env","date":"2019-11-12T08:14:06.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/Linux/env/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Linux/env/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/"}],"tags":[],"author":"Limbo"},{"title":"shell navigation","slug":"Linux/shell_navigation","date":"2019-11-12T08:14:06.000Z","updated":"2020-01-21T08:36:22.000Z","comments":true,"path":"wiki/Linux/shell_navigation/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Linux/shell_navigation/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/"}],"tags":[],"author":"Limbo"},{"title":"unix 哲学","slug":"Linux/unix","date":"2019-11-12T08:14:06.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/Linux/unix/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Linux/unix/","excerpt":"","text":"https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6","categories":[{"name":"Linux","slug":"Linux","permalink":"http://taizilongxu.github.io/wiki/categories/Linux/"}],"tags":[],"author":"Limbo"},{"title":"Ssh","slug":"Tools/ssh","date":"2019-11-05T09:00:36.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/Tools/ssh/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Tools/ssh/","excerpt":"","text":"","categories":[{"name":"Tools","slug":"Tools","permalink":"http://taizilongxu.github.io/wiki/categories/Tools/"}],"tags":[],"author":"Limbo"},{"title":"Git 原理","slug":"Tools/git","date":"2019-11-05T08:58:19.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/Tools/git/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Tools/git/","excerpt":"","text":"","categories":[{"name":"Tools","slug":"Tools","permalink":"http://taizilongxu.github.io/wiki/categories/Tools/"}],"tags":[],"author":"Limbo"},{"title":"使用 maven shade plugin 解决重复类问题","slug":"Language/Java/shaded","date":"2019-11-03T02:36:03.000Z","updated":"2020-01-15T12:06:59.000Z","comments":true,"path":"wiki/Language/Java/shaded/","link":"","permalink":"http://taizilongxu.github.io/wiki/wiki/Language/Java/shaded/","excerpt":"","text":"使用 Maven 大概都遇到过重复类的问题, 轻则程序异常, 重则无法运行, 一般有一下几个方法来处理: maven &lt;exclusions&gt; 用来排除重复类, 只对兼容性好的依赖有效, 如果两个版本依赖的接口有变动就 GG 了 可以祭出大招 classloader 来加载不同的类, 这个方法可以 cover 所有重复类, 但是有个缺点就是代码侵入性比较强, 我就是想引两个版本还要写一堆代码, 岂不是蛋疼 使用框架, 比如说阿里的 sofa-jarslink, 其本质也是基于 classloader 在底层进行封装 使用 Maven Shade Plugin 进行类名转换, 然后引入依赖, 对于用 1 方法不见效, 又不想使用 2 方法来说, 这个是很好的折衷, 不用对代码进行更改, 只需要修改 pom 文件 去 官网 看看 Maven Shade Plugin 可以干什么? 可以生成 Uber JAR, 而且可以决定 include 和 exclude 重命名 class 防止打成的 Uber Jar 类冲突 设置 mainClass Resource 转换 今天重点来说一下如何使用 Maven Shade Plugin 来实现多版本加载 Maven 依赖原则 优先按照依赖管理中 &lt;dependencyManagement&gt; 指定版本进行仲裁 若无版本声明, 则按照最短路径优先 若路径一致, 则选择最先声明的版本 问题工作中我们搭建的 Flink SQL 平台需要进行 Kafka 的连接, 蛋疼的是生产上 Kafka 版本有几种, 短时间内不能统一, 需要兼容各个版本, 如下图所示: 根据 Maven 依赖的原则, 在 pom 里优先加载了 Kafka-client-0.8, 轮到加载 Kafka-client-0.11 认为该依赖是重复的, 并不在 classloader 里进行加载, 解决方法 为了便于维护管理可以将原来的单模块换为多模块, 分别新建 shaded-Kafka-connector-0.8 和 shaded-Kafka-connector-0.11 模块, 注意里面不用写代码, 仅仅写一个 pom 文件即可 shaded 模块中引入各自的 Kafka-connector 依赖, 将 Kafka-client 模块用 Maven shade plugin relocation 到 shaded-Kafka-client 我们的原工程不再引用 Kafka-connector 模块, 而是分别引用 shade-Kafka-connector, 这样就将不通的 Kafka-client 进行了隔离 这个方法有一点坏处就是, 你只能使用生成出来的 Uber JAR 来运行才不会冲突, 像 Idea 里面不会识别这种 shaded 的包, 在 Idea 里运行还是会报错的, 相关 issue 开源软件用法许多开源软件也面临着这个问题, 比如说臭名昭著的 guava 在升级的道路上绝不妥协, 导致兼容性极差, Flink 单独用一个 flink-shade 来单独 shade 一份进行引用 资料 To shade or not to shade","categories":[{"name":"Language","slug":"Language","permalink":"http://taizilongxu.github.io/wiki/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://taizilongxu.github.io/wiki/categories/Language/Java/"}],"tags":[],"author":"Limbo"}]}