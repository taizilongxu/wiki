<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Limbo&#39;s Wiki</title>
  
  
  <link href="/wiki/atom.xml" rel="self"/>
  
  <link href="http://taizilongxu.github.io/wiki/"/>
  <updated>2020-02-09T15:55:23.562Z</updated>
  <id>http://taizilongxu.github.io/wiki/</id>
  
  <author>
    <name>Limbo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚拟文件系统</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/vfs/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/vfs/</id>
    <published>2020-02-09T15:54:44.180Z</published>
    <updated>2020-02-09T15:55:23.562Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CFS 调度算法</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/cfs/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/cfs/</id>
    <published>2020-02-06T16:08:13.922Z</published>
    <updated>2020-02-06T17:24:48.559Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li><a href="https://blog.acean.vip/post/linux-kernel/gai-shu-linuxnei-he-san-jia-ma-che-zhi-jin-cheng-guan-li" target="_blank" rel="noopener">https://blog.acean.vip/post/linux-kernel/gai-shu-linuxnei-he-san-jia-ma-che-zhi-jin-cheng-guan-li</a></li></ul><p>Completely Fair Scheduler: 完全公平调度器</p><ul><li>核内调度</li><li>只处理 TASK_RUNINNG 状态的 task_struct</li><li>只针对 normal 线程</li></ul><p>算法关键:</p><ul><li><p>红黑树</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200207012316.png" alt=""></p></li><li><p><code>vtime = ptime * 1024 / weight</code> ptime 为实际执行时间, weight 为 权重, 跟你 nice 值对应</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.acean.vip/post/linux-kernel/gai-shu-linuxnei-he-san-jia-ma-che-zhi-jin-cheng-guan-li&quot; target=&quot;_bla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://taizilongxu.github.io/wiki/wiki/saltstack/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/saltstack/</id>
    <published>2020-02-02T16:48:46.058Z</published>
    <updated>2020-02-02T16:48:49.929Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://taizilongxu.github.io/wiki/wiki/ansible/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/ansible/</id>
    <published>2020-02-02T16:48:36.601Z</published>
    <updated>2020-02-02T16:48:43.478Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>编译原理</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/compiler/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/compiler/</id>
    <published>2020-01-31T18:14:03.524Z</published>
    <updated>2020-01-31T18:17:39.622Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>switch 破解原理</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Hack/switch/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Hack/switch/</id>
    <published>2020-01-27T02:26:51.862Z</published>
    <updated>2020-01-31T18:16:27.562Z</updated>
    
    <content type="html"><![CDATA[<p>教程: <a href="https://github.com/ln93/kosmos_chs_tutorial" target="_blank" rel="noopener">https://github.com/ln93/kosmos_chs_tutorial</a></p><p>漏洞: Nvidia Tegra X1</p><p>破解原理: <a href="https://media.ccc.de/v/c4.openchaos.2018.06.glitching-the-switch#t=49" target="_blank" rel="noopener">https://media.ccc.de/v/c4.openchaos.2018.06.glitching-the-switch#t=49</a></p><p>破解原理简单版: <a href="https://www.youtube.com/watch?v=L3PPWVPg2WI&amp;vl=en" target="_blank" rel="noopener">https://www.youtube.com/watch?v=L3PPWVPg2WI&amp;vl=en</a></p><p>硬件参数:</p><ul><li>CPU: Tegra X1 T210</li><li>GPU: Nvidia Maxwell GPU</li><li>RAM: 4GB LPDDRR4</li></ul><p>大致破解原理:</p><ol><li><p>Tegra X1 有个 recovery 模式的漏洞, 这个是在和 switch 同样的硬件中发现的, 在 switch 里就是我们熟知的短接</p></li><li><p>这个漏洞主要利用 BootRom 启动的时候通过 USB 进行通讯</p><p>![image-20200128012739143](/Users/limbo/Library/Application Support/typora-user-images/image-20200128012739143.png)</p></li><li><p>USB 通讯有签名, 这个无法绕过</p><p>![image-20200128020009026](/Users/limbo/Library/Application Support/typora-user-images/image-20200128020009026.png)</p></li><li><p>但是可以控制通信协议长度, 让复制到 DMA 的内存溢出, 占用堆栈的地址, 函数返回的 stack 地址就可以接收系统控制权了</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200128020324.png" alt=""></p></li></ol><p>破解过程:</p><ol><li>TF 卡里先写入我们要接管的程序</li><li>通过短接 switch 进入 RCM 模式</li><li>通过 USB 连接电脑或者手机(注入 RCM), 通过注入跳转到我们写好的 TF 卡里的程序</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;教程: &lt;a href=&quot;https://github.com/ln93/kosmos_chs_tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ln93/kosmos_chs_tutorial&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Hack" scheme="http://taizilongxu.github.io/wiki/categories/Hack/"/>
    
    
  </entry>
  
  <entry>
    <title>docker internal</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/docker/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/docker/</id>
    <published>2020-01-22T09:29:30.607Z</published>
    <updated>2020-01-22T09:37:30.338Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@nagarwal/understanding-the-docker-internals-7ccb052ce9fe" target="_blank" rel="noopener">https://medium.com/@nagarwal/understanding-the-docker-internals-7ccb052ce9fe</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://medium.com/@nagarwal/understanding-the-docker-internals-7ccb052ce9fe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>cgroup</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/cgroup/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/cgroup/</id>
    <published>2020-01-22T07:00:22.615Z</published>
    <updated>2020-02-09T16:25:57.837Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料:</p><ul><li><a href="https://tech.meituan.com/2015/03/31/cgroups.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/03/31/cgroups.html</a></li><li><a href="https://blog.csdn.net/zsj100213/article/details/89088446" target="_blank" rel="noopener">https://blog.csdn.net/zsj100213/article/details/89088446</a></li><li><a href="http://www.manongjc.com/article/7475.html" target="_blank" rel="noopener">http://www.manongjc.com/article/7475.html</a></li></ul><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>cgroups(contol groups), google 工程师提出, 整合进 Linux 内核, 是 LXC 的基础</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p> 限制单个进程或多个进程使用资源, 可以对  cpu, mem 实现精细化的控制</p><ul><li>资源限制</li><li>优先级分配</li><li>资源统计</li><li>任务控制</li></ul><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200209234834.png" alt=""></p><ul><li>Filesystem: 类似于 /proc</li><li>subsystem: 可配置资源, 例如 cpu, mem</li><li>task: 进程在 cgroup 里称为 task, taskid 为 pid</li><li>libcgroup: 开源软件, 方便配置</li></ul><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200206175136.png" alt=""></p><p>说明:</p><ul><li>第一层为 subsystem, 对应不通的物理资源</li><li>第二层为 cgroup 结构体, 描述对应子系统的资源占用</li><li>css_set(cgroup subststem set) 辅助数据结构, 描述所有资源限制</li><li>P 进程, 一个进程对应一个 css_set</li></ul><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>查看挂载点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount | grep cgroup</span></span><br><span class="line">tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)  # tmpfs 内存临时文件呢</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br></pre></td></tr></table></figure><p>查看子系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /sys/fs/cgroup</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 5 root root  0 Nov 17  2018 blkio</span><br><span class="line">lrwxrwxrwx 1 root root 11 Nov 17  2018 cpu -&gt; cpu,cpuacct</span><br><span class="line">lrwxrwxrwx 1 root root 11 Nov 17  2018 cpuacct -&gt; cpu,cpuacct</span><br><span class="line">drwxr-xr-x 8 root root  0 Nov 17  2018 cpu,cpuacct</span><br><span class="line">drwxr-xr-x 3 root root  0 Nov 17  2018 cpuset</span><br><span class="line">drwxr-xr-x 5 root root  0 Nov 17  2018 devices</span><br><span class="line">drwxr-xr-x 4 root root  0 Nov 17  2018 freezer</span><br><span class="line">drwxr-xr-x 3 root root  0 Nov 17  2018 hugetlb</span><br><span class="line">drwxr-xr-x 8 root root  0 Nov 17  2018 memory</span><br><span class="line">drwxr-xr-x 3 root root  0 Nov 17  2018 net_cls</span><br><span class="line">drwxr-xr-x 3 root root  0 Nov 17  2018 perf_event</span><br><span class="line">drwxr-xr-x 5 root root  0 Nov 17  2018 systemd</span><br></pre></td></tr></table></figure><p>查看进程 cgroup</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/135/cgroup</span></span><br><span class="line">10:memory:/</span><br><span class="line">9:cpuset:/</span><br><span class="line">8:hugetlb:/</span><br><span class="line">7:perf_event:/</span><br><span class="line">6:net_cls:/</span><br><span class="line">5:freezer:/</span><br><span class="line">4:blkio:/</span><br><span class="line">3:cpuacct,cpu:/</span><br><span class="line">2:devices:/</span><br><span class="line">1:name=systemd:/</span><br></pre></td></tr></table></figure><h2 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/fs/cgroup/memory/memory.oom_control</span></span><br><span class="line">oom_kill_disable 0</span><br><span class="line">under_oom 0</span><br></pre></td></tr></table></figure><p>oom_kill_disable == 1: 程序进入休眠状态</p><p>oom_kill_disable == 0: 操作系统杀死</p><p>配置项</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>memory.usage_in_bytes</td><td>当前内存中的使用量</td></tr><tr><td>memory.memsw.usage_in_bytes</td><td>当前内存和交换空间中的使用量</td></tr><tr><td>memory.limit_in_bytes</td><td>设置or查看内存使用量</td></tr><tr><td>memory.memsw.limit_in_bytes</td><td>设置or查看 内存加交换空间使用量</td></tr><tr><td>memory.failcnt</td><td>查看内存使用量被限制的次数</td></tr><tr><td>memory.memsw.failcnt</td><td>查看内存和交换空间使用量被限制的次数</td></tr><tr><td>memory.max_usage_in_bytes</td><td>查看内存最大使用量</td></tr><tr><td>memory.memsw.max_usage_in_bytes</td><td>查看最大内存和交换空间使用量</td></tr><tr><td>memory.soft_limit_in_bytes</td><td>设置or查看内存的soft limit</td></tr><tr><td>memory.stat</td><td>统计信息</td></tr><tr><td>memory.use_hierarchy</td><td>设置or查看层级统计的功能</td></tr><tr><td>memory.force_empty</td><td>触发强制page回收</td></tr><tr><td>memory.pressure_level</td><td>设置内存压力通知</td></tr><tr><td>memory.swappiness</td><td>设置or查看vmscan swappiness 参数</td></tr><tr><td>memory.move_charge_at_immigrate</td><td>设置or查看 controls of moving charges</td></tr><tr><td>memory.oom_control</td><td>设置or查看内存超限控制信息(OOM killer)</td></tr><tr><td>memory.numa_stat</td><td>每个numa节点的内存使用数量</td></tr></tbody></table><p>内核 mem 控制:</p><ul><li>memory.kmem.limit_in_bytes # 设置or查看 内核内存限制的硬限</li><li>memory.kmem.usage_in_bytes # 读取当前内核内存的分配</li><li>memory.kmem.failcnt # 读取当前内核内存分配受限的次数</li><li>memory.kmem.max_usage_in_bytes # 读取最大内核内存使用量</li><li>memory.kmem.tcp.limit_in_bytes # 设置tcp 缓存内存的hard limit</li><li>memory.kmem.tcp.usage_in_bytes # 读取tcp 缓存内存的使用量</li><li>memory.kmem.tcp.failcnt # tcp 缓存内存分配的受限次数</li><li>memory.kmem.tcp.max_usage_in_bytes # tcp 缓存内存的最大使用量</li></ul><h2 id="CPU-限制"><a href="#CPU-限制" class="headerlink" title="CPU 限制"></a>CPU 限制</h2><ol><li>cpuset 以核心的方式进行隔离</li><li>cpuquota 以 cpu 使用比率限制, 保证比率上限</li><li>cpusharess 以权重比率弹性分配, 保证最低占用时间比率</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu]$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cgroup.clone_children</span><br><span class="line">--w--w--w-   1 root root 0 Nov 17  2018 cgroup.event_control</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cgroup.procs</span><br><span class="line">-r--r--r--   1 root root 0 Nov 17  2018 cgroup.sane_behavior</span><br><span class="line">-r--r--r--   1 root root 0 Nov 17  2018 cpuacct.stat</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpuacct.usage</span><br><span class="line">-r--r--r--   1 root root 0 Nov 17  2018 cpuacct.usage_percpu</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpu.cfs_period_us</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpu.cfs_quota_us</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpu.rt_period_us</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpu.rt_runtime_us</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpu.shares</span><br><span class="line">-r--r--r--   1 root root 0 Nov 17  2018 cpu.stat</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 notify_on_release</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 release_agent</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 tasks</span><br></pre></td></tr></table></figure><p>配置项</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>cpuset.cpus</td><td>可以使用的cpu节点</td></tr><tr><td>cpuset.mems:</td><td>可以使用的mem节点</td></tr><tr><td>cpuset.memory_migrate</td><td>内存节点改变是否要迁移</td></tr><tr><td>cpuset.cpu_exclusive</td><td>此cgroup里的任务是否独享cpu</td></tr><tr><td>cpuset.mem_exclusive</td><td>此cgroup里的任务是否独享mem节点</td></tr><tr><td>cpuset.mem_hardwall</td><td>限制内核内存分配的节点（mems是用户态的分配）</td></tr><tr><td>cpuset.memory_pressure</td><td>计算换页的压力</td></tr><tr><td>cpuset.memory_spread_page</td><td>将page cache分配到各个节点中，而不是当前内存节点</td></tr><tr><td>cpuset.memory_spread_slab</td><td>将slab对象(inode和dentry)分散到节点中</td></tr><tr><td>cpuset.sched_load_balance</td><td>打开cpu set中的cpu的负载均衡</td></tr><tr><td>cpuset.sched_relax_domain_level</td><td>the searching range when migrating tasks</td></tr><tr><td>cpuset.memory_pressure_enabled</td><td>是否需要计算 memory_pressure</td></tr></tbody></table><h2 id="cgroup-与-systemd-关系"><a href="#cgroup-与-systemd-关系" class="headerlink" title="cgroup 与 systemd 关系"></a>cgroup 与 systemd 关系</h2><p>其实没啥关系, 但是 systemd 兼容 cgroup, 可以在 cgroup 之上启动</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200206232211.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tech.meituan.com/2015/03/31/cgroups.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tech.meituan.com/201
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux boot</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Linux/boot/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Linux/boot/</id>
    <published>2020-01-21T09:47:45.066Z</published>
    <updated>2020-02-06T07:43:40.835Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料:</p><ul><li><a href="http://www.nixhacker.com/explaining-the-magic-of-mbr-and-its/" target="_blank" rel="noopener">http://www.nixhacker.com/explaining-the-magic-of-mbr-and-its/</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li></ul><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200121175449.png" alt=""></p><ol><li>BIOS: Basic Input/Output System 硬件检测, 自检完后找到 MBR 移交执行</li><li>MBR: Master Boot Record</li><li>GRUB:  Grand Unified Bootloader 负责选择多个系统 img</li><li>Kernal: Linux kenel 内核启动</li><li>init: 启动各种程序</li></ol><h2 id="BIOS-amp-UEFI"><a href="#BIOS-amp-UEFI" class="headerlink" title="BIOS &amp; UEFI"></a>BIOS &amp; UEFI</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/maxresdefault.jpg" alt=""></p><ol><li>1980s 开始 BIOS 系统</li><li>应对 BIOS 限制, 2006 年 Intel 开发 EFI, 苹果采用</li><li>2007 年 UEFI 问世, 统一标准</li></ol><h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><figure class="highlight plain"><figcaption><span>GPT, 配合 UEFI 食用```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MBR:</span><br><span class="line"></span><br><span class="line">* 优点: 简单</span><br><span class="line">* 缺点: 只能 4 个分区, 不能识别大于 2T 的分区</span><br><span class="line"></span><br><span class="line">硬盘第一块 secotr 即为 MBR, 一般 512 bytes</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">sudo xxd -g 1 &#x2F;dev&#x2F;sda | head -40</span><br><span class="line"></span><br><span class="line">0000000: eb 63 90 10 8e d0 bc 00 b0 b8 00 00 8e d8 8e c0  .c..............</span><br><span class="line">0000010: fb be 00 7c bf 00 06 b9 00 02 f3 a4 ea 21 06 00  ...|.........!..</span><br><span class="line">0000020: 00 be be 07 38 04 75 0b 83 c6 10 81 fe fe 07 75  ....8.u........u</span><br><span class="line">0000030: f3 eb 16 b4 02 b0 01 bb 00 7c b2 80 8a 74 01 8b  .........|...t..</span><br><span class="line">0000040: 4c 02 cd 13 ea 00 7c 00 00 eb fe 00 00 00 00 00  L.....|.........</span><br></pre></td></tr></table></figure><p>MBR 结构:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200122115921.png" alt=""></p><h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/GNU_GRUB_on_MBR_partitioned_hard_disk_drives.svg/1280px-GNU_GRUB_on_MBR_partitioned_hard_disk_drives.svg.png" alt="img"></p><ul><li>boot.img: 严格占有 446 bytes, 主要作用就是调用 BIOS 来加载 core.img 的 sector 到内存</li><li>core.img: 写入位于 MBR 和第一分区之间的部分, 在 32256 bytes 以下, 并不用占满, 主要是 <code>GRUB 的内核</code>, 加载后掌握控制权</li><li>/boot/grub: 一些 grub 配置文件</li></ul><h2 id="Kernal"><a href="#Kernal" class="headerlink" title="Kernal"></a>Kernal</h2><p>Bootloader 进行 Kernal 的 img 镜像加载解压缩, 并给予控制权, 最后调用 init 进行其他启动</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200121180904.png" alt=""></p><h2 id="System-V-amp-Systemd"><a href="#System-V-amp-Systemd" class="headerlink" title="System V &amp; Systemd"></a>System V &amp; Systemd</h2><p>kernal 会调用 <code>/sbin/init</code> 来启动 uid 为 1 的守护进程, 有两种选择</p><ul><li>System V: 注意这个启动是串行, 很少在用,  感兴趣可以了解下,  命令 <code>service</code></li><li>Upstart: 基于事件机制</li><li>Systemd(地址会软链到<code>/lib/systemd/systemd</code>): 兼容 System V</li></ul><h3 id="System-V"><a href="#System-V" class="headerlink" title="System V"></a>System V</h3><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200122153855.png" alt=""></p><h3 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h3><p>配置地址: </p><ul><li><code>/lib/systemd/system</code> : 系统自带或程序自带安装地址</li><li><code>/etc/systemd/system</code>: 用户自定义, 可覆盖上面文件夹内容</li></ul><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200122153923.png" alt=""></p><p>概念说明:</p><ul><li>target: target 也属于 Unit 一种,  是 Unit 的逻辑集合(和 System V 的运行级别概念相同), 同时还有个 <code>*.target.wants</code> 文件放置它所管理的 Unit</li><li>Unit: <code>最小单元</code>, 分几种类型的资源, 例如 device, mount, target 和我们最常用的 service</li></ul><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200122162730.png" alt=""></p><p>上图启动 garphitcal.target 执行的依赖</p><p>常用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 常用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status/start/restart/stop/reload &lt;service&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有正在运行的, 类型为 service 的 Unit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl list-units --<span class="built_in">type</span>=service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看依赖</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl list-dependencies &lt;service&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl cat &lt;service&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看启动时的默认 Target</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl get-default</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看主机信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hostnamectl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前登录用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> loginctl list-sessions</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> loginctl list-users</span></span><br></pre></td></tr></table></figure><p>日志管理:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看内核日志（不显示应用日志）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl -k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定进程的日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl _PID=1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个路径的脚本的日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl /usr/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个 Unit 的日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl -u nginx.service</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl -u nginx.service --since today</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定时间的日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl --since=<span class="string">"2012-10-30 18:17:16"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl --since <span class="string">"20 min ago"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl --since yesterday</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl --since <span class="string">"2015-01-10"</span> --until <span class="string">"2015-01-11 03:00"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.nixhacker.com/explaining-the-magic-of-mbr-and-its/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.nixh
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://taizilongxu.github.io/wiki/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Class 文件结构</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Language/Java/class_bytes/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Language/Java/class_bytes/</id>
    <published>2020-01-20T17:36:05.000Z</published>
    <updated>2020-01-22T09:30:11.132Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li><a href="https://coolshell.cn/articles/9229.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9229.html</a></li><li><a href="http://luckylau.tech/2017/05/26/你懂java吗-11/" target="_blank" rel="noopener">http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/</a></li></ul><p><img src="http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/1.png" alt="img"></p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>0XCAFEBABE </p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p><img src="http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/18.png" alt="img"></p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200121013404.png" alt=""></p><p><img src="http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/4.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/9229.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coolshell.cn/articles/9229.html
      
    
    </summary>
    
    
      <category term="Language" scheme="http://taizilongxu.github.io/wiki/categories/Language/"/>
    
      <category term="Java" scheme="http://taizilongxu.github.io/wiki/categories/Language/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM Memory</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Language/Java/jvm/jvm_mem/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Language/Java/jvm/jvm_mem/</id>
    <published>2020-01-20T16:00:12.000Z</published>
    <updated>2020-01-20T16:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_mem_1.png" alt=""></p><p>JVM 主要三个组成:</p><ul><li>Heap: 所有实例对象, 堆内空间无法扩展出现 OOM 异常<ul><li>Young Generation(默认比例 8:1:1)<ul><li>Eden</li><li>From Survivor</li><li>To Survivor</li></ul></li><li>Old Generation</li></ul></li><li>Method Area(<code>Non-Heap, PermGen, 永久代</code>): 方法区存储类信息, 常量, 静态变量等数据, 线程共享区域, 方法区也会抛出 OOM</li><li>Stack<ul><li>Java Stack: 每个方法执行的时候都会创建一个 stack frame, 保存局部变量, 操作栈,动态链接, 方法出口等, 如果线程请求栈的深度大于虚拟机允许深度, 抛出 stackoverflow 异常, 如果虚拟机栈可以动态扩展, 当无法申请内存是会抛出 OOM 异常</li><li>Native Method Stack: 存一些原生方法, C 库</li></ul></li></ul><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_mem_2.png" alt=""></p><h2 id="其他内存占用"><a href="#其他内存占用" class="headerlink" title="其他内存占用"></a>其他内存占用</h2><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO使用java.nio.ByteBuffer.allocateDirect()方法分配内存，每次分配内存都会调用操作系统函数os::malloc()，所以，分配的内存是本机的内存而不是Java堆上的内存；</p><p> 另外利用该方法产生的数据和网络、磁盘发生交互的时候都是在内核空间发生的，不需要复制到用户空间Java内存中，这种技术避免了Java堆和本机堆之间的数据复制；但是利用该方法生成的数据会作为Java堆GC的一部分来自动清理本机缓冲区。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200120235923.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_mem_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;JVM 主要三个组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Heap: 所有实例对
      
    
    </summary>
    
    
      <category term="Language" scheme="http://taizilongxu.github.io/wiki/categories/Language/"/>
    
      <category term="Java" scheme="http://taizilongxu.github.io/wiki/categories/Language/Java/"/>
    
      <category term="jvm" scheme="http://taizilongxu.github.io/wiki/categories/Language/Java/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>欢迎来到我的 Wiki</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/index/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/index/</id>
    <published>2020-01-20T15:45:04.000Z</published>
    <updated>2020-02-05T06:27:23.231Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://taizilongxu.github.io/wiki/wiki/BigData/Kafka/cheat_sheet/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/BigData/Kafka/cheat_sheet/</id>
    <published>2020-01-15T12:06:59.175Z</published>
    <updated>2020-01-15T12:06:59.175Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="BigData" scheme="http://taizilongxu.github.io/wiki/categories/BigData/"/>
    
      <category term="Kafka" scheme="http://taizilongxu.github.io/wiki/categories/BigData/Kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>crontab</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Linux/crontab/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Linux/crontab/</id>
    <published>2020-01-15T12:06:59.174Z</published>
    <updated>2020-01-15T12:12:26.138Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[xuxiao.xu@l-rtools1.ops.cna ~]$ cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name  command to be executed</span></span><br></pre></td></tr></table></figure><p><a href="https://crontab.guru/" target="_blank" rel="noopener">https://crontab.guru/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://taizilongxu.github.io/wiki/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>shell</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Linux/shell/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Linux/shell/</id>
    <published>2020-01-15T12:06:59.173Z</published>
    <updated>2020-01-21T12:13:35.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell-原理"><a href="#Shell-原理" class="headerlink" title="Shell 原理"></a>Shell 原理</h2><p>系统提供 shell 给用户调用内核</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/LinuxShell.png" alt=""></p><p>执行过程:</p><ol><li>读取用户键盘指令</li><li>分析命令，以命令名作为文件名，并将其它参数改造为系统调用 <code>execve()</code> 内部处理所要求的形式 </li><li>终端进程调用 <code>fork()</code> 建立一个子进程</li><li>终端进程本身用系统调用 <code>wait4()</code> 来等待子进程完成(如果是后台命令，则不等待). 当子进程运行时调用 <code>execve()</code>，子进程根据文件名(即命令名)到目录中查找有关文件(这是命令解释程序构成的文件), 将它调入内存, 执行这个程序(解释这条命令)</li><li>如果命令末尾有&amp;号(后台命令符号), 则终端进程不用系统调用 <code>wait4()</code> 等待, 立即发提示符, 让用户输入下一个命令, 转 1 如果命令末尾没有 &amp; 号, 则终端进程要一直等待, 当子进程(即运行命令的进程)完成处理后终止, 向父进程(终端进程)报告, 此时终端进程醒来, 在做必要的判别等工作后, 终端进程发提示符, 让用户输入新的命令, 重复上述处理过程.</li></ol><h2 id="内置-Shell-命令"><a href="#内置-Shell-命令" class="headerlink" title="内置 Shell 命令"></a>内置 Shell 命令</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/linux_shell_cmd.png" alt=""></p><h2 id="Shell-navigation"><a href="#Shell-navigation" class="headerlink" title="Shell navigation"></a>Shell navigation</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/cli-navigation.png" alt=""></p><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/package_management.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shell-原理&quot;&gt;&lt;a href=&quot;#Shell-原理&quot; class=&quot;headerlink&quot; title=&quot;Shell 原理&quot;&gt;&lt;/a&gt;Shell 原理&lt;/h2&gt;&lt;p&gt;系统提供 shell 给用户调用内核&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ra
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://taizilongxu.github.io/wiki/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Maven 汇总</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Language/Java/maven/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Language/Java/maven/</id>
    <published>2020-01-15T12:06:59.168Z</published>
    <updated>2020-01-15T12:06:59.169Z</updated>
    
    <content type="html"><![CDATA[<p>Maven 是常用的 Java 构建工具, 以 POM 文件为中心,  Maven 工作时的几个主要步骤</p><ol><li>读取 pom.xml</li><li>下载依赖到本地</li><li>执行构建过程</li><li>执行插件</li></ol><h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>POM - Project Object Model 具体可参见 <a href="http://maven.apache.org/guides/introduction/introduction-to-the-pom.html" target="_blank" rel="noopener">官网 POM 介绍</a></p><h1 id="依赖包管理"><a href="#依赖包管理" class="headerlink" title="依赖包管理"></a>依赖包管理</h1><ol><li>Maven 会递归下载 POM 文件中的依赖, 可以用 <code>&lt;exclusions&gt;</code> 进行排除</li><li>Maven 下载的依赖来自 3 个地方:<ul><li>本地 <code>%USER_HOME%/.m2</code> 目录</li><li>中央仓库</li><li>远程库</li></ul></li></ol><h1 id="理解-Lifecycle-Phase-Goal"><a href="#理解-Lifecycle-Phase-Goal" class="headerlink" title="理解 Lifecycle, Phase, Goal"></a>理解 Lifecycle, Phase, Goal</h1><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/POM.png" alt=""></p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>上面图里可以看到 Maven 自带 3 个 Lifecycle:</p><ul><li>default: 主要生命周期, 编译代码并处理打包项目</li><li>clean: 清理构建输出, 包括中间文件</li><li>site: 文档生成</li></ul><h2 id="Phase"><a href="#Phase" class="headerlink" title="Phase"></a>Phase</h2><p><code>default</code> 的 Lifecycle 包含了许多 phase, 常见如下, 完整可以查看 <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference" target="_blank" rel="noopener">Lifecycle Referrence</a></p><ul><li>validate: 验证项目</li><li>compile: 编译代码</li><li>test: 测试</li><li>package: 将编译后代码打包</li><li>install: 安装到本地存储</li><li>deploy: 发布到远程仓库</li></ul><p>当我们执行 <code>mvn install</code> 时, 实际会按照顺序执行前置的各个 phase, 例如 validate -&gt; compile -&gt; test -&gt; package -&gt; install 最终执行到 install</p><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>Maven 为插件提供了 Goal 来注册到各个 phase 进行执行</p><h2 id="Maven-是如何组合这些过程的"><a href="#Maven-是如何组合这些过程的" class="headerlink" title="Maven 是如何组合这些过程的"></a>Maven 是如何组合这些过程的</h2><p>在 POM 中有一个 <code>&lt;packaging&gt;</code> 选项, 默认会是 <code>jar</code>, 这个 <code>packaging</code> 会绑定一些 <code>goal</code> 到各个 <code>phase</code>, 默认可查看 <a href="http://maven.apache.org/ref/3.6.2/maven-core/default-bindings.html" target="_blank" rel="noopener">Plugin Bindings</a>, 举个例子 <code>jar</code> 的默认绑定:</p><table><thead><tr><th align="left">Phase</th><th align="left">plugin:goal</th></tr></thead><tbody><tr><td align="left">process-resources</td><td align="left">resources:resources</td></tr><tr><td align="left">compile</td><td align="left">compiler:compile</td></tr><tr><td align="left">process-test-resources</td><td align="left">resources:testResources</td></tr><tr><td align="left">test-compile</td><td align="left">compiler:testCompile</td></tr><tr><td align="left">test</td><td align="left">surefire:test</td></tr><tr><td align="left">package</td><td align="left">jar:jar</td></tr><tr><td align="left">install</td><td align="left">install:install</td></tr><tr><td align="left">deploy</td><td align="left">deploy:deploy</td></tr></tbody></table><p>Maven 在按照 lifecycle 进行运行的时候会执行各个 phase 中的 goal</p><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>如果我们想要在不同阶段对打包进行控制, 可以设置 scope 参数, <a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope" target="_blank" rel="noopener">官网</a></p><p>对应不通的编译阶段我们可以参考下图</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/scope.png" alt=""></p><ul><li>compile: 默认设置, 参与整个打包的周期</li><li>provided: 比如说我们提交 Flink 任务到集群里, 很多包集群是已经附带的, 我们就可以把该包设置成 provided, 减少打包体积</li><li>runtime: 这个一般用 jdbc 可以选填, 只有在运行时才需要</li><li>test: 测试阶段用到的包</li><li>system: 从本地引用包, 不会去仓库下载, 配合 systemPath 使用</li></ul><p>对于依赖的传递, 可以举例:</p><p>A - comiple -&gt; B - provided -&gt; C 或者<br>A - comiple -&gt; B - test -&gt; C 时 A 将丢弃 C, 不会引用</p><p>下面是具体的引用传递:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/scope_depedency.png" alt=""></p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul><li><a href="https://maven.apache.org/index.html" target="_blank" rel="noopener">Maven 官网</a></li><li><a href="https://www.qikegu.com/docs/2454" target="_blank" rel="noopener">Maven 教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Maven 是常用的 Java 构建工具, 以 POM 文件为中心,  Maven 工作时的几个主要步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取 pom.xml&lt;/li&gt;
&lt;li&gt;下载依赖到本地&lt;/li&gt;
&lt;li&gt;执行构建过程&lt;/li&gt;
&lt;li&gt;执行插件&lt;/li&gt;
&lt;/ol&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Language" scheme="http://taizilongxu.github.io/wiki/categories/Language/"/>
    
      <category term="Java" scheme="http://taizilongxu.github.io/wiki/categories/Language/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM 简介 (翻译)</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Language/Java/jvm/jvm/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Language/Java/jvm/jvm/</id>
    <published>2020-01-15T12:06:59.168Z</published>
    <updated>2020-01-15T12:06:59.168Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.guru99.com/java-virtual-machine-jvm.html" target="_blank" rel="noopener">https://www.guru99.com/java-virtual-machine-jvm.html</a></p><h2 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM ?"></a>什么是 JVM ?</h2><p>Java Virtual Machine (JVM) 是提供 Java 代码和应用运行环境的引擎. 它可以将 Java 字节码转换成机器码. JVM 是 Java Run Environment (JRE) 的一部分. 在其他语言里, 编译器为特定的系统产生机器码, 然而, Java 编译器产生的代码直接提供给虚拟机, 就是我们熟知的 JVM</p><h3 id="JVM-如何工作"><a href="#JVM-如何工作" class="headerlink" title="JVM 如何工作"></a>JVM 如何工作</h3><p>首先, Java 代码编译成字节码. 这个字节码可以在不同的机器上解析.</p><p>字节码是介于主机系统和 Java 源码之间的中间语言.</p><p>JVM 负责分配内存空间</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_work.png" alt=""></p><h2 id="JVM-架构"><a href="#JVM-架构" class="headerlink" title="JVM 架构"></a>JVM 架构</h2><p>让我们来了解下 JVM 的架构. 它包含了 classloader, memory area, execution egine 等.</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_arch.png" alt=""></p><ol><li>ClassLoader: 类加载器是一个加载类文件的子系统, 包括 3 个主要功能, Loading, Linking 和 Initialization</li><li>Method Area: JVM 方法区保存像 metadata, 持久的运行池和代码方法</li><li>Heap: 所有的 Object, 他们相关的 instance 变量, 数组都存在 heap 里, 这些内存可以在不同线程间分享</li><li>JVM Language Stacks: 存储 local 变量, 和一部分结果. <strong><em>每个线程都有自己的 JVM stack</em></strong>, 创建线程的同时它们也会被创建. 当一个方法被 invoke 时, 新的 frame 就会被创建, 当方法 invocation process 完成时也就会被删除.</li><li>PC Registers: 保存正在执行的代码地址. 在 Java 中, <strong><em>每个线程有自己的 PC register</em></strong>.</li><li>Native Method Stacks: 保存原生库的地方. 通常都是其他语言的代码.</li><li>Execution Engine: It is a type of software used to test hardware, software, or complete systems. The test execution engine never carries any information about the tested product.</li><li>Native Method interface: 编程框架. 允许 Java 代码在 JVM 里调用库和原生应用.</li><li>Native Method Libraries: Execution Engine 需要的一些原生库(C, C++)</li></ol><h2 id="代码编译和执行过程"><a href="#代码编译和执行过程" class="headerlink" title="代码编译和执行过程"></a>代码编译和执行过程</h2><p>为了书写和执行一个软件, 你需要:</p><ol><li>Editor: 输入你的代码</li><li>Compile: 讲你的高级语言转换成机器语言</li><li>Linker: 将不同的程序文件合并在你的 main 程序里.</li><li>Loader: 讲文件从硬盘里加载到 RAM 里. Loading 的过程是在执行代码的时候自动执行的</li><li>Execution: 通过操作系统和进程来执行你的代码</li></ol><h2 id="C-代码编译和执行过程"><a href="#C-代码编译和执行过程" class="headerlink" title="C 代码编译和执行过程"></a>C 代码编译和执行过程</h2><p>为了理解 Java 编译过程, 先让我们简单看一下 C 语言是如何编译和链接的</p><p>假设你的 main 函数里调用了 f1 和 f2 两个函数. main 函数保存在 a1.c 文件里</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_c_1.png" alt=""></p><p>f1 函数保存在 a2.c 文件里</p><p>f2 函数保存在 a3.c 文件里</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_c_3.png" alt=""></p><p>所有文件, a1.c, a2.c 和 a3.c 通过 compiler 输出为机器码</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_c_4.png" alt=""></p><p>下一步就是通过 linker 将所有这些 object 文件打包成一个 exe 文件</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_c_5.png" alt=""></p><p>在程序运行期间, 一个 loader 程序将会把 a.exe load 进 Ram 里来执行</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_c_6.png" alt=""></p><h2 id="Java-代码在-JVM-里编译和执行"><a href="#Java-代码在-JVM-里编译和执行" class="headerlink" title="Java 代码在 JVM 里编译和执行"></a>Java 代码在 JVM 里编译和执行</h2><p>让我们看看 Java 程序. 在你的 main 函数里有 f1 , f2 两个函数</p><ul><li>main 方法存在 a1.java 文件</li><li>f1 存在 a2.java 文件</li><li>f2 存在 a3.java 文件</li></ul><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_java_1.png" alt=""></p><p>compiller 将会产出 3 个以 .class 命名的字节码文件. 不像 C, 没有 linking 的过程.</p><p>JVM 存在于 RAM 中. 在执行期间, 使用 class loader 把 class 文件装载进 RAM, </p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_java_2.png" alt=""></p><p>下一步,  execution engine 将会把字节码转换为机器码,这是在 compile 时候进行的. 这就是为什么相对来说 Java 运行的比较慢.</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_java_3.png" alt=""></p><p>NOTE: JIT 或者说 Just-in-time compiler 是 JVM 的一部分. It interprets part of the Byte Code that has similar functionality at the same time.</p><h2 id="为什么-Java-既是解析又是编译语言"><a href="#为什么-Java-既是解析又是编译语言" class="headerlink" title="为什么 Java 既是解析又是编译语言?"></a>为什么 Java 既是解析又是编译语言?</h2><p>程序语言分类</p><ul><li>高级语言: C++, Java</li><li>中等语言: C</li><li>低级语言: Assembly</li><li>最低级语言: 机器语言</li></ul><p>compiler 可以将一个程序从一级语言转化为另一级语言, 例如将 C++ 转为机器语言</p><p>java compiler 将高级的 java 代码转换为字节码(也是一种机器码)</p><p>interpreter 可以将同一级别的语言转化为相同级别的语言.例如 Java 程序转换为 C++</p><p>在 Java 中 JIT 将字节码转换为机器码是相同语言级别的转换</p><p>所以, Java 既是解析又是编译语言</p><h2 id="为什么-Java-慢"><a href="#为什么-Java-慢" class="headerlink" title="为什么 Java 慢?"></a>为什么 Java 慢?</h2><p>主要两个原因:</p><ol><li>动态链接: 不像 C, Java 在运行时链接</li><li>运行时解析: 字节码是在运行时转换为机器码. 所以速度有所减慢</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.guru99.com/java-virtual-machine-jvm.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.guru99.com/java-virtual-machine
      
    
    </summary>
    
    
      <category term="Language" scheme="http://taizilongxu.github.io/wiki/categories/Language/"/>
    
      <category term="Java" scheme="http://taizilongxu.github.io/wiki/categories/Language/Java/"/>
    
      <category term="jvm" scheme="http://taizilongxu.github.io/wiki/categories/Language/Java/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>RAID</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Hardware/Disk/raid/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Hardware/Disk/raid/</id>
    <published>2020-01-15T12:06:59.165Z</published>
    <updated>2020-01-15T12:06:59.165Z</updated>
    
    <content type="html"><![CDATA[<p>RAID是英文Redundant Array of Independent Disks的缩写, 即磁盘冗余阵列.</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid.png" alt=""></p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid_table.png" alt=""></p><h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h2><p>分散打在不同磁盘上, 写入速度 * n</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid0.png" alt=""></p><h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h2><p>镜像对考， 双写</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid1.png" alt=""></p><h2 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h2><p>校验块分布在不同磁盘上, 易于扩展</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid5.png" alt=""></p><h2 id="Raid-6"><a href="#Raid-6" class="headerlink" title="Raid 6"></a>Raid 6</h2><p>采用两种独立的校验算法</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid6.png" alt=""></p><h2 id="RAID-组合"><a href="#RAID-组合" class="headerlink" title="RAID 组合"></a>RAID 组合</h2><p>组合方式, 速度既快, 又有备份</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid01.png" alt=""></p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid10.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RAID是英文Redundant Array of Independent Disks的缩写, 即磁盘冗余阵列.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/img/master/img/ra
      
    
    </summary>
    
    
      <category term="Hardware" scheme="http://taizilongxu.github.io/wiki/categories/Hardware/"/>
    
      <category term="Disk" scheme="http://taizilongxu.github.io/wiki/categories/Hardware/Disk/"/>
    
    
  </entry>
  
  <entry>
    <title>硬盘接口</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Hardware/Disk/interface/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Hardware/Disk/interface/</id>
    <published>2020-01-15T12:06:59.165Z</published>
    <updated>2020-01-15T12:06:59.165Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">名称</th><th align="center">总线</th><th align="center">物理接口</th><th>协议</th><th>年份</th><th>带宽</th><th>理论速度</th><th>编码</th></tr></thead><tbody><tr><td align="center">SATA 1.0</td><td align="center">SATA</td><td align="center">SATA</td><td>AHCI</td><td>2003</td><td>1.5 Gb/s</td><td>150 MB/s</td><td>8 b / 10 b</td></tr><tr><td align="center">SATA 2.0</td><td align="center">SATA</td><td align="center">SATA</td><td>AHCI</td><td>2004</td><td>3 Gb/s</td><td>300 MB/s</td><td>8 b / 10 b</td></tr><tr><td align="center">SATA 3.0</td><td align="center">SATA</td><td align="center">SATA</td><td>AHCI</td><td>2009</td><td>6 Gb/s</td><td>600 MB/s</td><td>8 b / 10 b</td></tr><tr><td align="center">SATA Express(SATA 3.2)</td><td align="center">SATA</td><td align="center">SATA</td><td></td><td>2014</td><td>16 Gb/s</td><td>1969 MB/s</td><td>128 b / 130 b</td></tr><tr><td align="center">M.2 SATA</td><td align="center">SATA</td><td align="center">M.2</td><td>AHCI</td><td>2013</td><td>6 Gb/s</td><td>600 MB/s</td><td></td></tr><tr><td align="center">M.2 NVMe</td><td align="center">NVMe</td><td align="center">M.2</td><td>PCIe</td><td>2013</td><td>32 Gb/s</td><td>3200 MB/s</td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/interface.png" alt=""></p><p>上面这个图有点问题, Technology 那一行的 SATA 都改为 AHCI</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;名称&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;总线&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;物理接口&lt;/th&gt;
&lt;th&gt;协议&lt;/th&gt;
&lt;th&gt;年份&lt;/th&gt;
&lt;th&gt;带宽&lt;/th&gt;

      
    
    </summary>
    
    
      <category term="Hardware" scheme="http://taizilongxu.github.io/wiki/categories/Hardware/"/>
    
      <category term="Disk" scheme="http://taizilongxu.github.io/wiki/categories/Hardware/Disk/"/>
    
    
  </entry>
  
  <entry>
    <title>Wi-Fi 协议</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Hardware/wifi/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Hardware/wifi/</id>
    <published>2020-01-15T12:06:59.164Z</published>
    <updated>2020-01-15T12:06:59.164Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">名称</th><th align="center">代号</th><th align="center">年代</th><th align="center">频段</th><th align="center">带宽</th></tr></thead><tbody><tr><td align="center">802.11b</td><td align="center">Wi-Fi 1</td><td align="center">1999</td><td align="center">2.4 GHz</td><td align="center">11 Mbps</td></tr><tr><td align="center">802.11a</td><td align="center">Wi-Fi 2</td><td align="center">1999</td><td align="center">5 GHz</td><td align="center">54 Mbps</td></tr><tr><td align="center">802.11g</td><td align="center">Wi-Fi 3</td><td align="center">2003</td><td align="center">2.4 GHz</td><td align="center">54 Mbps</td></tr><tr><td align="center">802.11n</td><td align="center">Wi-Fi 4</td><td align="center">2009</td><td align="center">2.4 GHz / 5 GHz</td><td align="center">450 Mbps</td></tr><tr><td align="center">802.11ac</td><td align="center">Wi-Fi 5</td><td align="center">2014</td><td align="center">2.4 GHz / 5 GHz</td><td align="center">866.7 Mbps</td></tr><tr><td align="center">802.11ax</td><td align="center">Wi-Fi 6</td><td align="center">2019</td><td align="center">2.4 GHz / 5 GHz</td><td align="center">1201 Mbps</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;名称&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;代号&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;年代&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;频段&lt;/th&gt;
&lt;th align=&quot;
      
    
    </summary>
    
    
      <category term="Hardware" scheme="http://taizilongxu.github.io/wiki/categories/Hardware/"/>
    
    
  </entry>
  
</feed>
