<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Limbo&#39;s Wiki</title>
  
  
  <link href="/wiki/atom.xml" rel="self"/>
  
  <link href="http://taizilongxu.github.io/wiki/"/>
  <updated>2020-02-19T16:30:22.726Z</updated>
  <id>http://taizilongxu.github.io/wiki/</id>
  
  <author>
    <name>Limbo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>下载原理</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/download/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/download/</id>
    <published>2020-02-19T16:29:58.638Z</published>
    <updated>2020-02-19T16:30:22.726Z</updated>
    
    <content type="html"><![CDATA[<p> Torrent</p><p>Magnet</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; Torrent&lt;/p&gt;
&lt;p&gt;Magnet&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>食材</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/GYM/gym/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/GYM/gym/</id>
    <published>2020-02-18T13:46:07.435Z</published>
    <updated>2020-02-24T17:23:27.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>电饭锅</li><li>电磁炉: 米家电磁炉青春版</li><li>煎锅, 雪平锅</li><li>厨房纸</li><li>砧板</li><li>刀具: 三德刀基本够用, 后期升级可以加个切片刀</li></ul><h2 id="拌料"><a href="#拌料" class="headerlink" title="拌料"></a>拌料</h2><ul><li>橄榄油, PAM</li><li>黑胡椒</li><li>孜然</li><li>盐</li><li>酱油</li><li>料酒</li><li>耗油</li></ul><h2 id="食材"><a href="#食材" class="headerlink" title="食材"></a>食材</h2><p>蛋白质</p><table><thead><tr><th align="center">名称</th><th align="center">GI</th><th align="center">热量大卡</th><th align="center">常温存储</th><th align="center">冷藏存储</th><th align="center">冷冻存储</th></tr></thead><tbody><tr><td align="center">牛肉🐂</td><td align="center">46</td><td align="center">318</td><td align="center">2小时</td><td align="center">1-2天</td><td align="center">6-8月</td></tr><tr><td align="center">鸡胸肉🐓</td><td align="center">45</td><td align="center">200</td><td align="center">2小时</td><td align="center">1-2天</td><td align="center">1年</td></tr><tr><td align="center">龙利鱼🐟</td><td align="center">40</td><td align="center">67</td><td align="center">2小时</td><td align="center">1-2天</td><td align="center">6-9月</td></tr><tr><td align="center">金枪鱼🐟</td><td align="center">40</td><td align="center">99</td><td align="center">2小时</td><td align="center">1-2天</td><td align="center">6-9月</td></tr><tr><td align="center">沙丁鱼🐟</td><td align="center">40</td><td align="center">89</td><td align="center">2小时</td><td align="center">1-2天</td><td align="center">6-9月</td></tr><tr><td align="center">虾仁🍤</td><td align="center">40</td><td align="center">83</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">鸡蛋🥚</td><td align="center">30</td><td align="center">151</td><td align="center">数小时</td><td align="center">3-4周</td><td align="center">不可</td></tr><tr><td align="center">牛奶🥛</td><td align="center">25</td><td align="center">67</td><td align="center">数小时</td><td align="center">5-7天</td><td align="center">1个月</td></tr><tr><td align="center">培根🥓</td><td align="center">49</td><td align="center">405</td><td align="center">2小时</td><td align="center">2周</td><td align="center">4个月</td></tr></tbody></table><p>蔬菜</p><table><thead><tr><th align="center">名称</th><th align="center">GI</th><th align="center">热量大卡</th><th align="center">常温存储</th><th align="center">冷藏存储</th><th align="center">冷冻存储</th></tr></thead><tbody><tr><td align="center">玉米🌽</td><td align="center">70</td><td align="center">92</td><td align="center">1-3天</td><td align="center">1-2周</td><td align="center">3-5月</td></tr><tr><td align="center">红萝卜🥕</td><td align="center">80</td><td align="center">37</td><td align="center">4天</td><td align="center">4-5周</td><td align="center">8-12月</td></tr><tr><td align="center">马铃薯🥔</td><td align="center">90</td><td align="center">65</td><td align="center">1个月</td><td align="center">3-4月</td><td align="center">不可冷冻</td></tr><tr><td align="center">红薯</td><td align="center">76</td><td align="center">61</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">山药</td><td align="center">75</td><td align="center">50</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">番茄🍅</td><td align="center">30</td><td align="center">19</td><td align="center">5-7天</td><td align="center">2周</td><td align="center">8-12月</td></tr><tr><td align="center">黄瓜🥒</td><td align="center">23</td><td align="center">14</td><td align="center">1-3天</td><td align="center">1周</td><td align="center">8-12月</td></tr><tr><td align="center">西兰花🥦</td><td align="center">25</td><td align="center">36</td><td align="center">2天</td><td align="center">7-14天</td><td align="center">8-12月</td></tr><tr><td align="center">南瓜🎃</td><td align="center">65</td><td align="center">91</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>主食</p><table><thead><tr><th align="center">名称</th><th align="center">GI</th><th align="center">热量大卡</th></tr></thead><tbody><tr><td align="center">米饭🍚</td><td align="center">84</td><td align="center">356</td></tr><tr><td align="center">馒头</td><td align="center">88</td><td align="center">233</td></tr><tr><td align="center">糙米🍚</td><td align="center">56</td><td align="center">350</td></tr><tr><td align="center">燕麦🥣</td><td align="center">55</td><td align="center">380</td></tr><tr><td align="center">全麦面包🍞</td><td align="center">50</td><td align="center">378</td></tr><tr><td align="center">黑麦面包🍞</td><td align="center">58</td><td align="center">264</td></tr><tr><td align="center">意大利面🍝</td><td align="center">55</td><td align="center">378</td></tr><tr><td align="center">荞麦面🍝</td><td align="center">59</td><td align="center">274</td></tr></tbody></table><p>水果</p><table><thead><tr><th align="center">名称</th><th align="center">GI</th><th align="center">热量大卡</th><th align="center">常温存储</th><th align="center">冷藏存储</th><th align="center">冷冻存储</th></tr></thead><tbody><tr><td align="center">香蕉🍌</td><td align="center">55</td><td align="center">154</td><td align="center">2-7天</td><td align="center">5-9天</td><td align="center">2-3个月</td></tr><tr><td align="center">芒果🥭</td><td align="center">49</td><td align="center">64</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">哈密瓜🍈</td><td align="center">41</td><td align="center">42</td><td align="center">熟透之前</td><td align="center">1周</td><td align="center">8-12月</td></tr><tr><td align="center">桃子🍑</td><td align="center">41</td><td align="center">40</td><td align="center">熟透之前</td><td align="center">2-5天</td><td align="center">8-12个月</td></tr><tr><td align="center">苹果🍎</td><td align="center">36</td><td align="center">54</td><td align="center">2-4周</td><td align="center">1-2月</td><td align="center">8-12月</td></tr><tr><td align="center">奇异果🥝</td><td align="center">35</td><td align="center">35</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">梨🍐</td><td align="center">32</td><td align="center">43</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">木瓜</td><td align="center">30</td><td align="center">38</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">橙子🍊</td><td align="center">31</td><td align="center">46</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">橘子🍊</td><td align="center">31</td><td align="center">60</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">柠檬🍋</td><td align="center">34</td><td align="center">54</td><td align="center">2-4周</td><td align="center">1-2月</td><td align="center">3-4月</td></tr><tr><td align="center">草莓🍓</td><td align="center">29</td><td align="center">34</td><td align="center">1-2天</td><td align="center">5-7天</td><td align="center">6-8个月</td></tr><tr><td align="center">葡萄🍇</td><td align="center">50</td><td align="center">55</td><td align="center">3-5天</td><td align="center">7-10天</td><td align="center">3-5个月</td></tr></tbody></table><h2 id="健身餐"><a href="#健身餐" class="headerlink" title="健身餐"></a>健身餐</h2><h3 id="牛排"><a href="#牛排" class="headerlink" title="牛排"></a>牛排</h3><p>素材</p><ul><li><p>牛排</p></li><li><p>橄榄油</p></li><li><p>黑胡椒</p></li><li><p>盐</p></li></ul><p>过程</p><ol><li>冷藏解冻, 室温解冻或者冷水解冻</li><li>不用水清洗, 用厨房纸擦干水分</li><li>室温回温至少 30 min 以上, 厚的 1 小时以上</li><li>抹上橄榄油, 两面用黑胡椒和盐调味</li><li>15s 一次翻面</li><li>醒肉</li><li>吃</li></ol><h3 id="电饭锅煮鸡蛋"><a href="#电饭锅煮鸡蛋" class="headerlink" title="电饭锅煮鸡蛋"></a>电饭锅煮鸡蛋</h3><p>素材</p><ul><li>鸡蛋</li><li>水</li></ul><p>过程</p><ul><li>电饭锅铺上餐厨纸</li><li>均匀浇上 100ml 水</li><li>等待跳闸后闷 5 分钟</li><li>拿出放入凉水冷却好扒皮</li></ul><h3 id="蒸紫薯"><a href="#蒸紫薯" class="headerlink" title="蒸紫薯"></a>蒸紫薯</h3><p>素材:</p><ul><li>紫薯</li></ul><p>过程</p><ul><li>切块</li><li>蒸 10-20 分钟</li><li>去皮搅碎即可</li></ul><h3 id="煎鸡胸肉"><a href="#煎鸡胸肉" class="headerlink" title="煎鸡胸肉"></a>煎鸡胸肉</h3><p>素材:</p><ul><li>鸡胸</li></ul><p>过程</p><ul><li>解冻, 室温或者流水</li><li>切片或块, 更容易煎, 然后倒入生抽, 料酒和耗油腌制 30 分钟<ul><li>生抽, 料酒, 耗油腌制</li><li>黑胡椒, 海盐</li><li>盐, 胡椒, 卡真粉</li></ul></li><li>大火煎至两面金黄色</li></ul><h3 id="意面"><a href="#意面" class="headerlink" title="意面"></a>意面</h3><p>素材:</p><ul><li>意面</li></ul><h3 id="燕麦片"><a href="#燕麦片" class="headerlink" title="燕麦片"></a>燕麦片</h3><ul><li><p>燕麦片</p></li><li><p>牛奶</p></li><li><p>香蕉</p></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;硬件&quot;&gt;&lt;a href=&quot;#硬件&quot; class=&quot;headerlink&quot; title=&quot;硬件&quot;&gt;&lt;/a&gt;硬件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;电饭锅&lt;/li&gt;
&lt;li&gt;电磁炉: 米家电磁炉青春版&lt;/li&gt;
&lt;li&gt;煎锅, 雪平锅&lt;/li&gt;
&lt;li&gt;厨房纸&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="GYM" scheme="http://taizilongxu.github.io/wiki/categories/GYM/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux namespace</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Linux/container/namespace/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Linux/container/namespace/</id>
    <published>2020-02-11T16:25:00.488Z</published>
    <updated>2020-02-11T17:20:00.853Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料:</p><ul><li><a href="https://creaink.github.io/post/Computer/Linux/Linux-namespace.html" target="_blank" rel="noopener">https://creaink.github.io/post/Computer/Linux/Linux-namespace.html</a></li><li><a href="https://draveness.me/docker" target="_blank" rel="noopener">https://draveness.me/docker</a></li></ul><p>Linux namespace 是 Linux 提供的一种内核级别环境隔离方法</p><p>分类</p><table><thead><tr><th>namespace</th><th>隔离内容</th><th>flag</th><th>内核</th></tr></thead><tbody><tr><td>UTS</td><td>主机名</td><td>CLONE_NEWUTS</td><td>Linux 2.4.19</td></tr><tr><td>IPC</td><td>进程间通信</td><td>CLONE_NEWIPC</td><td>Linux 2.6.19</td></tr><tr><td>PID</td><td>chroot 进程树</td><td>CLONE_NEWPID</td><td>Linux 2.6.19</td></tr><tr><td>NS(Mount)</td><td>挂载点</td><td>CLONE_NEWNS</td><td>Linux 2.6.24</td></tr><tr><td>NET</td><td>网络访问, 包括接口</td><td>CLONE_NEWNET</td><td>Linux 2.6.29</td></tr><tr><td>USER</td><td>蒋虚拟的本地 UID 映射到真实的 UID</td><td>CLONE_NEWUSER</td><td>Linux 3.8</td></tr></tbody></table><p>三个系统调用</p><ul><li>clonne() 类似 fork, 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。</li><li>unshare() 使某进程脱离某个namespace</li><li>setns() 把某进程加入到某个namespace</li></ul><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p><code>/proc/[pid]/ns/</code> 目录下包含了某个进程的 namespace 所属，在 shell 中 <code>$$</code> 为当前进程 PID 所以可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /proc/$$/ns</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  5 00:13 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 net -&gt; net:[4026531957]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  4 06:18 uts -&gt; uts:[4026531838]</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> readlink /proc/$$/ns/uts</span></span><br><span class="line">uts:[4026531838]</span><br><span class="line"><span class="meta">$</span><span class="bash"> readlink /proc/<span class="variable">$PPID</span>/ns/uts</span></span><br><span class="line">uts:[4026531838]</span><br></pre></td></tr></table></figure><p><code>/proc/[pid]/mounts</code> 目录展现了进程的挂载点，而 <code>/proc/[pid]/mountinfo</code> 里的内容更详细。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://creaink.github.io/post/Computer/Linux/Linux-namespace.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cr
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://taizilongxu.github.io/wiki/categories/Linux/"/>
    
      <category term="container" scheme="http://taizilongxu.github.io/wiki/categories/Linux/container/"/>
    
    
  </entry>
  
  <entry>
    <title>chroot</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Linux/container/chroot/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Linux/container/chroot/</id>
    <published>2020-02-11T16:18:37.641Z</published>
    <updated>2020-02-11T17:28:04.630Z</updated>
    
    <content type="html"><![CDATA[<p>chroot  = change root directory 限制根目录, 防止越权</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/chroot-300x225.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;chroot  = change root directory 限制根目录, 防止越权&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/img/master/img/chroot-300x225.
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://taizilongxu.github.io/wiki/categories/Linux/"/>
    
      <category term="container" scheme="http://taizilongxu.github.io/wiki/categories/Linux/container/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟文件系统</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/vfs/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/vfs/</id>
    <published>2020-02-09T15:54:44.180Z</published>
    <updated>2020-02-09T15:55:23.562Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CFS 调度算法</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Linux/cfs/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Linux/cfs/</id>
    <published>2020-02-06T16:08:13.922Z</published>
    <updated>2020-02-06T17:24:48.559Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li><a href="https://blog.acean.vip/post/linux-kernel/gai-shu-linuxnei-he-san-jia-ma-che-zhi-jin-cheng-guan-li" target="_blank" rel="noopener">https://blog.acean.vip/post/linux-kernel/gai-shu-linuxnei-he-san-jia-ma-che-zhi-jin-cheng-guan-li</a></li></ul><p>Completely Fair Scheduler: 完全公平调度器</p><ul><li>核内调度</li><li>只处理 TASK_RUNINNG 状态的 task_struct</li><li>只针对 normal 线程</li></ul><p>算法关键:</p><ul><li><p>红黑树</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200207012316.png" alt=""></p></li><li><p><code>vtime = ptime * 1024 / weight</code> ptime 为实际执行时间, weight 为 权重, 跟你 nice 值对应</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.acean.vip/post/linux-kernel/gai-shu-linuxnei-he-san-jia-ma-che-zhi-jin-cheng-guan-li&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://taizilongxu.github.io/wiki/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://taizilongxu.github.io/wiki/wiki/saltstack/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/saltstack/</id>
    <published>2020-02-02T16:48:46.058Z</published>
    <updated>2020-02-02T16:48:49.929Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://taizilongxu.github.io/wiki/wiki/ansible/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/ansible/</id>
    <published>2020-02-02T16:48:36.601Z</published>
    <updated>2020-02-02T16:48:43.478Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>编译原理</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/compiler/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/compiler/</id>
    <published>2020-01-31T18:14:03.524Z</published>
    <updated>2020-01-31T18:17:39.622Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>switch 破解原理</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Hack/switch/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Hack/switch/</id>
    <published>2020-01-27T02:26:51.862Z</published>
    <updated>2020-01-31T18:16:27.562Z</updated>
    
    <content type="html"><![CDATA[<p>教程: <a href="https://github.com/ln93/kosmos_chs_tutorial" target="_blank" rel="noopener">https://github.com/ln93/kosmos_chs_tutorial</a></p><p>漏洞: Nvidia Tegra X1</p><p>破解原理: <a href="https://media.ccc.de/v/c4.openchaos.2018.06.glitching-the-switch#t=49" target="_blank" rel="noopener">https://media.ccc.de/v/c4.openchaos.2018.06.glitching-the-switch#t=49</a></p><p>破解原理简单版: <a href="https://www.youtube.com/watch?v=L3PPWVPg2WI&amp;vl=en" target="_blank" rel="noopener">https://www.youtube.com/watch?v=L3PPWVPg2WI&amp;vl=en</a></p><p>硬件参数:</p><ul><li>CPU: Tegra X1 T210</li><li>GPU: Nvidia Maxwell GPU</li><li>RAM: 4GB LPDDRR4</li></ul><p>大致破解原理:</p><ol><li><p>Tegra X1 有个 recovery 模式的漏洞, 这个是在和 switch 同样的硬件中发现的, 在 switch 里就是我们熟知的短接</p></li><li><p>这个漏洞主要利用 BootRom 启动的时候通过 USB 进行通讯</p><p>![image-20200128012739143](/Users/limbo/Library/Application Support/typora-user-images/image-20200128012739143.png)</p></li><li><p>USB 通讯有签名, 这个无法绕过</p><p>![image-20200128020009026](/Users/limbo/Library/Application Support/typora-user-images/image-20200128020009026.png)</p></li><li><p>但是可以控制通信协议长度, 让复制到 DMA 的内存溢出, 占用堆栈的地址, 函数返回的 stack 地址就可以接收系统控制权了</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200128020324.png" alt=""></p></li></ol><p>破解过程:</p><ol><li>TF 卡里先写入我们要接管的程序</li><li>通过短接 switch 进入 RCM 模式</li><li>通过 USB 连接电脑或者手机(注入 RCM), 通过注入跳转到我们写好的 TF 卡里的程序</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;教程: &lt;a href=&quot;https://github.com/ln93/kosmos_chs_tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ln93/kosmos_chs_tutorial&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Hack" scheme="http://taizilongxu.github.io/wiki/categories/Hack/"/>
    
    
  </entry>
  
  <entry>
    <title>docker internal</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/docker/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/docker/</id>
    <published>2020-01-22T09:29:30.607Z</published>
    <updated>2020-02-11T17:29:20.682Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@nagarwal/understanding-the-docker-internals-7ccb052ce9fe" target="_blank" rel="noopener">https://medium.com/@nagarwal/understanding-the-docker-internals-7ccb052ce9fe</a></p><p>Docker 底层三大技术 union filesystem, cgroup, namespace</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://medium.com/@nagarwal/understanding-the-docker-internals-7ccb052ce9fe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>cgroup</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Linux/container/cgroup/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Linux/container/cgroup/</id>
    <published>2020-01-22T07:00:22.615Z</published>
    <updated>2020-02-11T16:19:19.519Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料:</p><ul><li><a href="https://tech.meituan.com/2015/03/31/cgroups.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/03/31/cgroups.html</a></li><li><a href="https://blog.csdn.net/zsj100213/article/details/89088446" target="_blank" rel="noopener">https://blog.csdn.net/zsj100213/article/details/89088446</a></li><li><a href="http://www.manongjc.com/article/7475.html" target="_blank" rel="noopener">http://www.manongjc.com/article/7475.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/81668069" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81668069</a></li></ul><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>cgroups(contol groups), google 工程师提出, 整合进 Linux 内核, 是 LXC 的基础</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p> 限制单个进程或多个进程使用资源, 可以对  cpu, mem 实现精细化的控制</p><ul><li>资源限制</li><li>优先级分配</li><li>资源统计</li><li>任务控制</li></ul><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200209234834.png" alt=""></p><ul><li>Filesystem: 类似于 /proc</li><li>subsystem: 可配置资源, 例如 cpu, mem</li><li>task: 进程在 cgroup 里称为 task, taskid 为 pid</li><li>libcgroup: 开源软件, 方便配置</li></ul><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200206175136.png" alt=""></p><p>说明:</p><ul><li>第一层为 subsystem, 对应不通的物理资源</li><li>第二层为 cgroup 结构体, 描述对应子系统的资源占用</li><li>css_set(cgroup subststem set) 辅助数据结构, 描述所有资源限制</li><li>P 进程, 一个进程对应一个 css_set</li></ul><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>查看挂载点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount | grep cgroup</span></span><br><span class="line">tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)  # tmpfs 内存临时文件呢</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br></pre></td></tr></table></figure><p>查看子系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /sys/fs/cgroup</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 5 root root  0 Nov 17  2018 blkio</span><br><span class="line">lrwxrwxrwx 1 root root 11 Nov 17  2018 cpu -&gt; cpu,cpuacct</span><br><span class="line">lrwxrwxrwx 1 root root 11 Nov 17  2018 cpuacct -&gt; cpu,cpuacct</span><br><span class="line">drwxr-xr-x 8 root root  0 Nov 17  2018 cpu,cpuacct</span><br><span class="line">drwxr-xr-x 3 root root  0 Nov 17  2018 cpuset</span><br><span class="line">drwxr-xr-x 5 root root  0 Nov 17  2018 devices</span><br><span class="line">drwxr-xr-x 4 root root  0 Nov 17  2018 freezer</span><br><span class="line">drwxr-xr-x 3 root root  0 Nov 17  2018 hugetlb</span><br><span class="line">drwxr-xr-x 8 root root  0 Nov 17  2018 memory</span><br><span class="line">drwxr-xr-x 3 root root  0 Nov 17  2018 net_cls</span><br><span class="line">drwxr-xr-x 3 root root  0 Nov 17  2018 perf_event</span><br><span class="line">drwxr-xr-x 5 root root  0 Nov 17  2018 systemd</span><br></pre></td></tr></table></figure><p>查看进程 cgroup</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/135/cgroup</span></span><br><span class="line">10:memory:/</span><br><span class="line">9:cpuset:/</span><br><span class="line">8:hugetlb:/</span><br><span class="line">7:perf_event:/</span><br><span class="line">6:net_cls:/</span><br><span class="line">5:freezer:/</span><br><span class="line">4:blkio:/</span><br><span class="line">3:cpuacct,cpu:/</span><br><span class="line">2:devices:/</span><br><span class="line">1:name=systemd:/</span><br></pre></td></tr></table></figure><h2 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/fs/cgroup/memory/memory.oom_control</span></span><br><span class="line">oom_kill_disable 0</span><br><span class="line">under_oom 0</span><br></pre></td></tr></table></figure><p>oom_kill_disable == 1: 程序进入休眠状态</p><p>oom_kill_disable == 0: 操作系统杀死</p><p>配置项</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>memory.usage_in_bytes</td><td>当前内存中的使用量</td></tr><tr><td>memory.memsw.usage_in_bytes</td><td>当前内存和交换空间中的使用量</td></tr><tr><td>memory.limit_in_bytes</td><td>设置or查看内存使用量</td></tr><tr><td>memory.memsw.limit_in_bytes</td><td>设置or查看 内存加交换空间使用量</td></tr><tr><td>memory.failcnt</td><td>查看内存使用量被限制的次数</td></tr><tr><td>memory.memsw.failcnt</td><td>查看内存和交换空间使用量被限制的次数</td></tr><tr><td>memory.max_usage_in_bytes</td><td>查看内存最大使用量</td></tr><tr><td>memory.memsw.max_usage_in_bytes</td><td>查看最大内存和交换空间使用量</td></tr><tr><td>memory.soft_limit_in_bytes</td><td>设置or查看内存的soft limit</td></tr><tr><td>memory.stat</td><td>统计信息</td></tr><tr><td>memory.use_hierarchy</td><td>设置or查看层级统计的功能</td></tr><tr><td>memory.force_empty</td><td>触发强制page回收</td></tr><tr><td>memory.pressure_level</td><td>设置内存压力通知</td></tr><tr><td>memory.swappiness</td><td>设置or查看vmscan swappiness 参数</td></tr><tr><td>memory.move_charge_at_immigrate</td><td>设置or查看 controls of moving charges</td></tr><tr><td>memory.oom_control</td><td>设置or查看内存超限控制信息(OOM killer)</td></tr><tr><td>memory.numa_stat</td><td>每个numa节点的内存使用数量</td></tr></tbody></table><p>内核 mem 控制:</p><ul><li>memory.kmem.limit_in_bytes # 设置or查看 内核内存限制的硬限</li><li>memory.kmem.usage_in_bytes # 读取当前内核内存的分配</li><li>memory.kmem.failcnt # 读取当前内核内存分配受限的次数</li><li>memory.kmem.max_usage_in_bytes # 读取最大内核内存使用量</li><li>memory.kmem.tcp.limit_in_bytes # 设置tcp 缓存内存的hard limit</li><li>memory.kmem.tcp.usage_in_bytes # 读取tcp 缓存内存的使用量</li><li>memory.kmem.tcp.failcnt # tcp 缓存内存分配的受限次数</li><li>memory.kmem.tcp.max_usage_in_bytes # tcp 缓存内存的最大使用量</li></ul><h2 id="CPU-限制"><a href="#CPU-限制" class="headerlink" title="CPU 限制"></a>CPU 限制</h2><ol><li>cpuset 以核心的方式进行隔离</li><li>cpuquota 以 cpu 使用比率限制, 保证比率上限</li><li>cpusharess 以权重比率弹性分配, 保证最低占用时间比率</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu]$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cgroup.clone_children</span><br><span class="line">--w--w--w-   1 root root 0 Nov 17  2018 cgroup.event_control</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cgroup.procs</span><br><span class="line">-r--r--r--   1 root root 0 Nov 17  2018 cgroup.sane_behavior</span><br><span class="line">-r--r--r--   1 root root 0 Nov 17  2018 cpuacct.stat</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpuacct.usage</span><br><span class="line">-r--r--r--   1 root root 0 Nov 17  2018 cpuacct.usage_percpu</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpu.cfs_period_us</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpu.cfs_quota_us</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpu.rt_period_us</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpu.rt_runtime_us</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 cpu.shares</span><br><span class="line">-r--r--r--   1 root root 0 Nov 17  2018 cpu.stat</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 notify_on_release</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 release_agent</span><br><span class="line">-rw-r--r--   1 root root 0 Nov 17  2018 tasks</span><br></pre></td></tr></table></figure><p>配置项</p><p>cpu: 统限制对CPU的访问，每个参数独立存在于cgroups虚拟文件系统的伪文件中</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>cpu.shares</td><td>cgroup对时间的分配, 针对所有核。比如cgroup A设置的是1，cgroup B设置的是2，那么B中的任务获取cpu的时间，是A中任务的2倍</td></tr><tr><td>cpu.cfs_period_us</td><td>完全公平调度器的调整时间配额的周期,  取值范围 1ms - 1s</td></tr><tr><td>cpu.cfs_quota_us</td><td>完全公平调度器的周期当中可以占用的时间, 取值范围 &gt; 1ms, 如为 -1 即为无限制</td></tr><tr><td>cpu.stat</td><td></td></tr><tr><td>cpu.stat.nr_periods</td><td>进入周期的次数</td></tr><tr><td>cpu.stat.nr_throttled</td><td>运行时间被调整的次数</td></tr><tr><td>cpu.stat.throttled_time</td><td>用于调整的时间</td></tr></tbody></table><p>cpuacct: 生成cgroup任务所使用的CPU资源报告，不做资源限制功能</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>cpuacct.usage</td><td>该cgroup中所有任务总共使用的CPU时间（ns纳秒）</td></tr><tr><td>cpuacct.stat</td><td>该cgroup中所有任务总共使用的CPU时间，区分user和system时间</td></tr><tr><td>cpuacct.usage_percpu</td><td>该cgroup中所有任务使用各个CPU核数的时间</td></tr></tbody></table><p>cpuset: 适用于分配独立的CPU节点和Mem节点，比如将进程绑定在指定的CPU或者内存节点上运行</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>cpuset.cpus</td><td>可以使用的cpu节点</td></tr><tr><td>cpuset.mems</td><td>可以使用的mem节点</td></tr><tr><td>cpuset.memory_migrate</td><td>内存节点改变是否要迁移</td></tr><tr><td>cpuset.cpu_exclusive</td><td>此cgroup里的任务是否独享cpu</td></tr><tr><td>cpuset.mem_exclusive</td><td>此cgroup里的任务是否独享mem节点</td></tr><tr><td>cpuset.mem_hardwall</td><td>限制内核内存分配的节点（mems是用户态的分配）</td></tr><tr><td>cpuset.memory_pressure</td><td>计算换页的压力</td></tr><tr><td>cpuset.memory_spread_page</td><td>将page cache分配到各个节点中，而不是当前内存节点</td></tr><tr><td>cpuset.memory_spread_slab</td><td>将slab对象(inode和dentry)分散到节点中</td></tr><tr><td>cpuset.sched_load_balance</td><td>打开cpu set中的cpu的负载均衡</td></tr><tr><td>cpuset.sched_relax_domain_level</td><td>the searching range when migrating tasks</td></tr><tr><td>cpuset.memory_pressure_enable0d</td><td>是否需要计算 memory_pressure</td></tr></tbody></table><h2 id="cgroup-与-systemd-关系"><a href="#cgroup-与-systemd-关系" class="headerlink" title="cgroup 与 systemd 关系"></a>cgroup 与 systemd 关系</h2><p>其实没啥关系, 但是 systemd 兼容 cgroup, 可以在 cgroup 之上启动</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200206232211.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tech.meituan.com/2015/03/31/cgroups.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tech.meituan.com/201
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://taizilongxu.github.io/wiki/categories/Linux/"/>
    
      <category term="container" scheme="http://taizilongxu.github.io/wiki/categories/Linux/container/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux boot</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Linux/boot/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Linux/boot/</id>
    <published>2020-01-21T09:47:45.066Z</published>
    <updated>2020-02-06T07:43:40.835Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料:</p><ul><li><a href="http://www.nixhacker.com/explaining-the-magic-of-mbr-and-its/" target="_blank" rel="noopener">http://www.nixhacker.com/explaining-the-magic-of-mbr-and-its/</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li></ul><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200121175449.png" alt=""></p><ol><li>BIOS: Basic Input/Output System 硬件检测, 自检完后找到 MBR 移交执行</li><li>MBR: Master Boot Record</li><li>GRUB:  Grand Unified Bootloader 负责选择多个系统 img</li><li>Kernal: Linux kenel 内核启动</li><li>init: 启动各种程序</li></ol><h2 id="BIOS-amp-UEFI"><a href="#BIOS-amp-UEFI" class="headerlink" title="BIOS &amp; UEFI"></a>BIOS &amp; UEFI</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/maxresdefault.jpg" alt=""></p><ol><li>1980s 开始 BIOS 系统</li><li>应对 BIOS 限制, 2006 年 Intel 开发 EFI, 苹果采用</li><li>2007 年 UEFI 问世, 统一标准</li></ol><h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><figure class="highlight plain"><figcaption><span>GPT, 配合 UEFI 食用```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MBR:</span><br><span class="line"></span><br><span class="line">* 优点: 简单</span><br><span class="line">* 缺点: 只能 4 个分区, 不能识别大于 2T 的分区</span><br><span class="line"></span><br><span class="line">硬盘第一块 secotr 即为 MBR, 一般 512 bytes</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">sudo xxd -g 1 &#x2F;dev&#x2F;sda | head -40</span><br><span class="line"></span><br><span class="line">0000000: eb 63 90 10 8e d0 bc 00 b0 b8 00 00 8e d8 8e c0  .c..............</span><br><span class="line">0000010: fb be 00 7c bf 00 06 b9 00 02 f3 a4 ea 21 06 00  ...|.........!..</span><br><span class="line">0000020: 00 be be 07 38 04 75 0b 83 c6 10 81 fe fe 07 75  ....8.u........u</span><br><span class="line">0000030: f3 eb 16 b4 02 b0 01 bb 00 7c b2 80 8a 74 01 8b  .........|...t..</span><br><span class="line">0000040: 4c 02 cd 13 ea 00 7c 00 00 eb fe 00 00 00 00 00  L.....|.........</span><br></pre></td></tr></table></figure><p>MBR 结构:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200122115921.png" alt=""></p><h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/GNU_GRUB_on_MBR_partitioned_hard_disk_drives.svg/1280px-GNU_GRUB_on_MBR_partitioned_hard_disk_drives.svg.png" alt="img"></p><ul><li>boot.img: 严格占有 446 bytes, 主要作用就是调用 BIOS 来加载 core.img 的 sector 到内存</li><li>core.img: 写入位于 MBR 和第一分区之间的部分, 在 32256 bytes 以下, 并不用占满, 主要是 <code>GRUB 的内核</code>, 加载后掌握控制权</li><li>/boot/grub: 一些 grub 配置文件</li></ul><h2 id="Kernal"><a href="#Kernal" class="headerlink" title="Kernal"></a>Kernal</h2><p>Bootloader 进行 Kernal 的 img 镜像加载解压缩, 并给予控制权, 最后调用 init 进行其他启动</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200121180904.png" alt=""></p><h2 id="System-V-amp-Systemd"><a href="#System-V-amp-Systemd" class="headerlink" title="System V &amp; Systemd"></a>System V &amp; Systemd</h2><p>kernal 会调用 <code>/sbin/init</code> 来启动 uid 为 1 的守护进程, 有两种选择</p><ul><li>System V: 注意这个启动是串行, 很少在用,  感兴趣可以了解下,  命令 <code>service</code></li><li>Upstart: 基于事件机制</li><li>Systemd(地址会软链到<code>/lib/systemd/systemd</code>): 兼容 System V</li></ul><h3 id="System-V"><a href="#System-V" class="headerlink" title="System V"></a>System V</h3><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200122153855.png" alt=""></p><h3 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h3><p>配置地址: </p><ul><li><code>/lib/systemd/system</code> : 系统自带或程序自带安装地址</li><li><code>/etc/systemd/system</code>: 用户自定义, 可覆盖上面文件夹内容</li></ul><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200122153923.png" alt=""></p><p>概念说明:</p><ul><li>target: target 也属于 Unit 一种,  是 Unit 的逻辑集合(和 System V 的运行级别概念相同), 同时还有个 <code>*.target.wants</code> 文件放置它所管理的 Unit</li><li>Unit: <code>最小单元</code>, 分几种类型的资源, 例如 device, mount, target 和我们最常用的 service</li></ul><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200122162730.png" alt=""></p><p>上图启动 garphitcal.target 执行的依赖</p><p>常用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 常用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status/start/restart/stop/reload &lt;service&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有正在运行的, 类型为 service 的 Unit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl list-units --<span class="built_in">type</span>=service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看依赖</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl list-dependencies &lt;service&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl cat &lt;service&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看启动时的默认 Target</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl get-default</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看主机信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hostnamectl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前登录用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> loginctl list-sessions</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> loginctl list-users</span></span><br></pre></td></tr></table></figure><p>日志管理:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看内核日志（不显示应用日志）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl -k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定进程的日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl _PID=1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个路径的脚本的日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl /usr/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个 Unit 的日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl -u nginx.service</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl -u nginx.service --since today</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定时间的日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl --since=<span class="string">"2012-10-30 18:17:16"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl --since <span class="string">"20 min ago"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl --since yesterday</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl --since <span class="string">"2015-01-10"</span> --until <span class="string">"2015-01-11 03:00"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.nixhacker.com/explaining-the-magic-of-mbr-and-its/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.nixh
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://taizilongxu.github.io/wiki/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Class 文件结构</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Language/Java/class_bytes/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Language/Java/class_bytes/</id>
    <published>2020-01-20T17:36:05.000Z</published>
    <updated>2020-01-22T09:30:11.132Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li><a href="https://coolshell.cn/articles/9229.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9229.html</a></li><li><a href="http://luckylau.tech/2017/05/26/你懂java吗-11/" target="_blank" rel="noopener">http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/</a></li></ul><p><img src="http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/1.png" alt="img"></p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>0XCAFEBABE </p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p><img src="http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/18.png" alt="img"></p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200121013404.png" alt=""></p><p><img src="http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/4.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/9229.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coolshell.cn/articles/9229.html
      
    
    </summary>
    
    
      <category term="Language" scheme="http://taizilongxu.github.io/wiki/categories/Language/"/>
    
      <category term="Java" scheme="http://taizilongxu.github.io/wiki/categories/Language/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM Memory</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Language/Java/jvm/jvm_mem/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Language/Java/jvm/jvm_mem/</id>
    <published>2020-01-20T16:00:12.000Z</published>
    <updated>2020-01-20T16:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_mem_1.png" alt=""></p><p>JVM 主要三个组成:</p><ul><li>Heap: 所有实例对象, 堆内空间无法扩展出现 OOM 异常<ul><li>Young Generation(默认比例 8:1:1)<ul><li>Eden</li><li>From Survivor</li><li>To Survivor</li></ul></li><li>Old Generation</li></ul></li><li>Method Area(<code>Non-Heap, PermGen, 永久代</code>): 方法区存储类信息, 常量, 静态变量等数据, 线程共享区域, 方法区也会抛出 OOM</li><li>Stack<ul><li>Java Stack: 每个方法执行的时候都会创建一个 stack frame, 保存局部变量, 操作栈,动态链接, 方法出口等, 如果线程请求栈的深度大于虚拟机允许深度, 抛出 stackoverflow 异常, 如果虚拟机栈可以动态扩展, 当无法申请内存是会抛出 OOM 异常</li><li>Native Method Stack: 存一些原生方法, C 库</li></ul></li></ul><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_mem_2.png" alt=""></p><h2 id="其他内存占用"><a href="#其他内存占用" class="headerlink" title="其他内存占用"></a>其他内存占用</h2><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO使用java.nio.ByteBuffer.allocateDirect()方法分配内存，每次分配内存都会调用操作系统函数os::malloc()，所以，分配的内存是本机的内存而不是Java堆上的内存；</p><p> 另外利用该方法产生的数据和网络、磁盘发生交互的时候都是在内核空间发生的，不需要复制到用户空间Java内存中，这种技术避免了Java堆和本机堆之间的数据复制；但是利用该方法生成的数据会作为Java堆GC的一部分来自动清理本机缓冲区。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200120235923.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_mem_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;JVM 主要三个组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Heap: 所有实例对
      
    
    </summary>
    
    
      <category term="Language" scheme="http://taizilongxu.github.io/wiki/categories/Language/"/>
    
      <category term="Java" scheme="http://taizilongxu.github.io/wiki/categories/Language/Java/"/>
    
      <category term="jvm" scheme="http://taizilongxu.github.io/wiki/categories/Language/Java/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>欢迎来到我的 Wiki</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/index/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/index/</id>
    <published>2020-01-20T15:45:04.000Z</published>
    <updated>2020-02-05T06:27:23.231Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://taizilongxu.github.io/wiki/wiki/BigData/Kafka/cheat_sheet/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/BigData/Kafka/cheat_sheet/</id>
    <published>2020-01-15T12:06:59.175Z</published>
    <updated>2020-01-15T12:06:59.175Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="BigData" scheme="http://taizilongxu.github.io/wiki/categories/BigData/"/>
    
      <category term="Kafka" scheme="http://taizilongxu.github.io/wiki/categories/BigData/Kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>crontab</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Linux/crontab/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Linux/crontab/</id>
    <published>2020-01-15T12:06:59.174Z</published>
    <updated>2020-01-15T12:12:26.138Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[xuxiao.xu@l-rtools1.ops.cna ~]$ cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name  command to be executed</span></span><br></pre></td></tr></table></figure><p><a href="https://crontab.guru/" target="_blank" rel="noopener">https://crontab.guru/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://taizilongxu.github.io/wiki/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>shell</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Linux/shell/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Linux/shell/</id>
    <published>2020-01-15T12:06:59.173Z</published>
    <updated>2020-01-21T12:13:35.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell-原理"><a href="#Shell-原理" class="headerlink" title="Shell 原理"></a>Shell 原理</h2><p>系统提供 shell 给用户调用内核</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/LinuxShell.png" alt=""></p><p>执行过程:</p><ol><li>读取用户键盘指令</li><li>分析命令，以命令名作为文件名，并将其它参数改造为系统调用 <code>execve()</code> 内部处理所要求的形式 </li><li>终端进程调用 <code>fork()</code> 建立一个子进程</li><li>终端进程本身用系统调用 <code>wait4()</code> 来等待子进程完成(如果是后台命令，则不等待). 当子进程运行时调用 <code>execve()</code>，子进程根据文件名(即命令名)到目录中查找有关文件(这是命令解释程序构成的文件), 将它调入内存, 执行这个程序(解释这条命令)</li><li>如果命令末尾有&amp;号(后台命令符号), 则终端进程不用系统调用 <code>wait4()</code> 等待, 立即发提示符, 让用户输入下一个命令, 转 1 如果命令末尾没有 &amp; 号, 则终端进程要一直等待, 当子进程(即运行命令的进程)完成处理后终止, 向父进程(终端进程)报告, 此时终端进程醒来, 在做必要的判别等工作后, 终端进程发提示符, 让用户输入新的命令, 重复上述处理过程.</li></ol><h2 id="内置-Shell-命令"><a href="#内置-Shell-命令" class="headerlink" title="内置 Shell 命令"></a>内置 Shell 命令</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/linux_shell_cmd.png" alt=""></p><h2 id="Shell-navigation"><a href="#Shell-navigation" class="headerlink" title="Shell navigation"></a>Shell navigation</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/cli-navigation.png" alt=""></p><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/package_management.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shell-原理&quot;&gt;&lt;a href=&quot;#Shell-原理&quot; class=&quot;headerlink&quot; title=&quot;Shell 原理&quot;&gt;&lt;/a&gt;Shell 原理&lt;/h2&gt;&lt;p&gt;系统提供 shell 给用户调用内核&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ra
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://taizilongxu.github.io/wiki/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Maven 汇总</title>
    <link href="http://taizilongxu.github.io/wiki/wiki/Language/Java/maven/"/>
    <id>http://taizilongxu.github.io/wiki/wiki/Language/Java/maven/</id>
    <published>2020-01-15T12:06:59.168Z</published>
    <updated>2020-01-15T12:06:59.169Z</updated>
    
    <content type="html"><![CDATA[<p>Maven 是常用的 Java 构建工具, 以 POM 文件为中心,  Maven 工作时的几个主要步骤</p><ol><li>读取 pom.xml</li><li>下载依赖到本地</li><li>执行构建过程</li><li>执行插件</li></ol><h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>POM - Project Object Model 具体可参见 <a href="http://maven.apache.org/guides/introduction/introduction-to-the-pom.html" target="_blank" rel="noopener">官网 POM 介绍</a></p><h1 id="依赖包管理"><a href="#依赖包管理" class="headerlink" title="依赖包管理"></a>依赖包管理</h1><ol><li>Maven 会递归下载 POM 文件中的依赖, 可以用 <code>&lt;exclusions&gt;</code> 进行排除</li><li>Maven 下载的依赖来自 3 个地方:<ul><li>本地 <code>%USER_HOME%/.m2</code> 目录</li><li>中央仓库</li><li>远程库</li></ul></li></ol><h1 id="理解-Lifecycle-Phase-Goal"><a href="#理解-Lifecycle-Phase-Goal" class="headerlink" title="理解 Lifecycle, Phase, Goal"></a>理解 Lifecycle, Phase, Goal</h1><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/POM.png" alt=""></p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>上面图里可以看到 Maven 自带 3 个 Lifecycle:</p><ul><li>default: 主要生命周期, 编译代码并处理打包项目</li><li>clean: 清理构建输出, 包括中间文件</li><li>site: 文档生成</li></ul><h2 id="Phase"><a href="#Phase" class="headerlink" title="Phase"></a>Phase</h2><p><code>default</code> 的 Lifecycle 包含了许多 phase, 常见如下, 完整可以查看 <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference" target="_blank" rel="noopener">Lifecycle Referrence</a></p><ul><li>validate: 验证项目</li><li>compile: 编译代码</li><li>test: 测试</li><li>package: 将编译后代码打包</li><li>install: 安装到本地存储</li><li>deploy: 发布到远程仓库</li></ul><p>当我们执行 <code>mvn install</code> 时, 实际会按照顺序执行前置的各个 phase, 例如 validate -&gt; compile -&gt; test -&gt; package -&gt; install 最终执行到 install</p><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>Maven 为插件提供了 Goal 来注册到各个 phase 进行执行</p><h2 id="Maven-是如何组合这些过程的"><a href="#Maven-是如何组合这些过程的" class="headerlink" title="Maven 是如何组合这些过程的"></a>Maven 是如何组合这些过程的</h2><p>在 POM 中有一个 <code>&lt;packaging&gt;</code> 选项, 默认会是 <code>jar</code>, 这个 <code>packaging</code> 会绑定一些 <code>goal</code> 到各个 <code>phase</code>, 默认可查看 <a href="http://maven.apache.org/ref/3.6.2/maven-core/default-bindings.html" target="_blank" rel="noopener">Plugin Bindings</a>, 举个例子 <code>jar</code> 的默认绑定:</p><table><thead><tr><th align="left">Phase</th><th align="left">plugin:goal</th></tr></thead><tbody><tr><td align="left">process-resources</td><td align="left">resources:resources</td></tr><tr><td align="left">compile</td><td align="left">compiler:compile</td></tr><tr><td align="left">process-test-resources</td><td align="left">resources:testResources</td></tr><tr><td align="left">test-compile</td><td align="left">compiler:testCompile</td></tr><tr><td align="left">test</td><td align="left">surefire:test</td></tr><tr><td align="left">package</td><td align="left">jar:jar</td></tr><tr><td align="left">install</td><td align="left">install:install</td></tr><tr><td align="left">deploy</td><td align="left">deploy:deploy</td></tr></tbody></table><p>Maven 在按照 lifecycle 进行运行的时候会执行各个 phase 中的 goal</p><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>如果我们想要在不同阶段对打包进行控制, 可以设置 scope 参数, <a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope" target="_blank" rel="noopener">官网</a></p><p>对应不通的编译阶段我们可以参考下图</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/scope.png" alt=""></p><ul><li>compile: 默认设置, 参与整个打包的周期</li><li>provided: 比如说我们提交 Flink 任务到集群里, 很多包集群是已经附带的, 我们就可以把该包设置成 provided, 减少打包体积</li><li>runtime: 这个一般用 jdbc 可以选填, 只有在运行时才需要</li><li>test: 测试阶段用到的包</li><li>system: 从本地引用包, 不会去仓库下载, 配合 systemPath 使用</li></ul><p>对于依赖的传递, 可以举例:</p><p>A - comiple -&gt; B - provided -&gt; C 或者<br>A - comiple -&gt; B - test -&gt; C 时 A 将丢弃 C, 不会引用</p><p>下面是具体的引用传递:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/scope_depedency.png" alt=""></p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul><li><a href="https://maven.apache.org/index.html" target="_blank" rel="noopener">Maven 官网</a></li><li><a href="https://www.qikegu.com/docs/2454" target="_blank" rel="noopener">Maven 教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Maven 是常用的 Java 构建工具, 以 POM 文件为中心,  Maven 工作时的几个主要步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取 pom.xml&lt;/li&gt;
&lt;li&gt;下载依赖到本地&lt;/li&gt;
&lt;li&gt;执行构建过程&lt;/li&gt;
&lt;li&gt;执行插件&lt;/li&gt;
&lt;/ol&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Language" scheme="http://taizilongxu.github.io/wiki/categories/Language/"/>
    
      <category term="Java" scheme="http://taizilongxu.github.io/wiki/categories/Language/Java/"/>
    
    
  </entry>
  
</feed>
